//
// Type definitions for mscorlib, Version=1.0.1355.0, Culture=neutral, PublicKeyToken=null
//
// Generated by DuoCode Compiler 1.0.1355.0 [Trial]
//
declare type char = number | System.Char;
declare type sbyte = number | System.SByte;
declare type byte = number | System.Byte;
declare type short = number | System.Int16;
declare type ushort = number | System.UInt16;
declare type int = number | System.Int32;
declare type uint = number | System.UInt32;
declare type long = number | System.Int64;
declare type ulong = number | System.UInt64;
declare type decimal = number | System.Decimal;
declare type float = number | System.Single;
declare type double = number | System.Double;

interface TypeFunction extends Function {
    $type?: System.Type;
    $typeKind: number;
    $typeName: string;
    $baseType?: TypeFunction;
    $intfs?: TypeFunction[];
    $declaringType?: TypeFunction;
    $elementType?: TypeFunction;
    $unconstructedType?: TypeFunction;
    $underlyingType?: TypeFunction;
}

interface Array<T> extends System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable {
    GetEnumerator(): System.Collections.IEnumerator;
    get_Count(): int;
    get_SyncRoot(): any;
    get_IsSynchronized(): boolean;
    get_Rank(): int;
    CopyTo(array: Array<any>, index: int): void;
    CopyTo$1(array: Array<any>, index: long): void;
    get_IsReadOnly(): boolean;
    get_IsFixedSize(): boolean;
    get_IsTypedArray(): boolean;
    Clone(): any;
    GetLength(dimension: int): int;
    GetUpperBound(dimension: int): int;
    GetLowerBound(dimension: int): int;
    GetValue(index: int): any;
    SetValue(value: any, index: int): void;
    GetValue$1(index: long): any;
    SetValue$1(value: any, index: long): void;
}
interface ArrayConstructor {
    BinarySearch<T>(T, array: T[], value: T): int;
    BinarySearch$1<T>(T, array: T[], value: T, comparer: System.Collections.Generic.IComparer$1<T>): int;
    BinarySearch$2<T>(T, array: T[], index: int, length: int, value: T): int;
    BinarySearch$3<T>(T, array: T[], index: int, length: int, value: T, comparer: System.Collections.Generic.IComparer$1<T>): int;
    Copy(sourceArray: Array<any>, destinationArray: Array<any>, length: int): void;
    Copy$2(sourceArray: Array<any>, sourceIndex: int, destinationArray: Array<any>, destinationIndex: int, length: int): void;
    ConstrainedCopy(sourceArray: Array<any>, sourceIndex: int, destinationArray: Array<any>, destinationIndex: int, length: int): void;
    Copy$1(sourceArray: Array<any>, destinationArray: Array<any>, length: long): void;
    Copy$3(sourceArray: Array<any>, sourceIndex: long, destinationArray: Array<any>, destinationIndex: long, length: long): void;
    ConvertAll<TInput, TOutput>(TInput, TOutput, array: TInput[], converter: System.Converter$2<TInput, TOutput>): TOutput[];
    Clear(array: Array<any>, startIndex: int, length: int): void;
    ConvertToUntyped<T>(T, array: T[]): T[];
    Exists<T>(T, array: T[], match: System.Predicate$1<T>): boolean;
    Find<T>(T, array: T[], match: System.Predicate$1<T>): T;
    FindAll<T>(T, array: T[], match: System.Predicate$1<T>): T[];
    FindIndex<T>(T, array: T[], match: System.Predicate$1<T>): int;
    FindIndex$1<T>(T, array: T[], startIndex: int, match: System.Predicate$1<T>): int;
    FindIndex$2<T>(T, array: T[], startIndex: int, count: int, match: System.Predicate$1<T>): int;
    FindLast<T>(T, array: T[], match: System.Predicate$1<T>): T;
    FindLastIndex<T>(T, array: T[], match: System.Predicate$1<T>): int;
    FindLastIndex$1<T>(T, array: T[], startIndex: int, match: System.Predicate$1<T>): int;
    FindLastIndex$2<T>(T, array: T[], startIndex: int, count: int, match: System.Predicate$1<T>): int;
    ForEach<T>(T, array: T[], action: System.Action$1<T>): void;
    IndexOf(array: Array<any>, value: any): int;
    IndexOf$1(array: Array<any>, value: any, startIndex: int): int;
    IndexOf$2(array: Array<any>, value: any, startIndex: int, count: int): int;
    IndexOf$3<T>(T, array: T[], value: T): int;
    IndexOf$4<T>(T, array: T[], value: T, startIndex: int): int;
    IndexOf$5<T>(T, array: T[], value: T, startIndex: int, count: int): int;
    LastIndexOf(array: Array<any>, value: any): int;
    LastIndexOf$1(array: Array<any>, value: any, startIndex: int): int;
    LastIndexOf$2(array: Array<any>, value: any, startIndex: int, count: int): int;
    LastIndexOf$3<T>(T, array: T[], value: T): int;
    LastIndexOf$4<T>(T, array: T[], value: T, startIndex: int): int;
    LastIndexOf$5<T>(T, array: T[], value: T, startIndex: int, count: int): int;
    Resize<T>(T, array: T[], newSize: int): void;
    TrueForAll<T>(T, array: T[], match: System.Predicate$1<T>): boolean;
    CreateInstance(elementType: System.Type, length: int, forceUntyped: boolean): Array<any>;
    CreateInstance$1<T>(T, length: int, forceUntyped: boolean): T[];
    Sort(array: Array<any>): void;
    Sort$1(keys: Array<any>, items: Array<any>): void;
    Sort$4(array: Array<any>, index: int, length: int): void;
    Sort$5(keys: Array<any>, items: Array<any>, index: int, length: int): void;
    Sort$2(array: Array<any>, comparer: System.Collections.IComparer): void;
    Sort$3(keys: Array<any>, items: Array<any>, comparer: System.Collections.IComparer): void;
    Sort$6(array: Array<any>, index: int, length: int, comparer: System.Collections.IComparer): void;
    Sort$7(keys: Array<any>, items: Array<any>, index: int, length: int, comparer: System.Collections.IComparer): void;
    Sort$8<T>(T, array: T[]): void;
    Sort$13<TKey, TValue>(TKey, TValue, keys: TKey[], items: TValue[]): void;
    Sort$11<T>(T, array: T[], index: int, length: int): void;
    Sort$15<TKey, TValue>(TKey, TValue, keys: TKey[], items: TValue[], index: int, length: int): void;
    Sort$9<T>(T, array: T[], comparer: System.Collections.Generic.IComparer$1<T>): void;
    Sort$14<TKey, TValue>(TKey, TValue, keys: TKey[], items: TValue[], comparer: System.Collections.Generic.IComparer$1<TKey>): void;
    Sort$12<T>(T, array: T[], index: int, length: int, comparer: System.Collections.Generic.IComparer$1<T>): void;
    Sort$16<TKey, TValue>(TKey, TValue, keys: TKey[], items: TValue[], index: int, length: int, comparer: System.Collections.Generic.IComparer$1<TKey>): void;
    Sort$10<T>(T, array: T[], comparison: System.Comparison$1<T>): void;
    Reverse(array: Array<any>): void;
    Reverse$1(array: Array<any>, index: int, length: int): void;
}

interface Boolean extends System.ValueType, System.IComparable, System.IComparable$1<Boolean>, System.IEquatable$1<Boolean> {
    ToString$1(provider: System.IFormatProvider): string;
    CompareTo(obj: any): int;
}
interface BooleanConstructor {
    TrueString: string;
    FalseString: string;
    Parse(value: string): boolean;
    TryParse(value: string, result: boolean): boolean;
}

interface String extends System.Object, System.IComparable, System.IComparable$1<String>, System.Collections.Generic.IEnumerable$1<System.Char>, System.Collections.IEnumerable, System.IEquatable$1<String> {
    get_Chars(index: int): char;
    IndexOf(value: char): int;
    IndexOf$1(value: char, startIndex: int): int;
    LastIndexOf(value: char): int;
    LastIndexOf$1(value: char, startIndex: int): int;
    EndsWith(value: string): boolean;
    StartsWith(value: string): boolean;
    StartsWith$1(value: string, comparisonType: System.StringComparison): boolean;
    Substring(startIndex: int): string;
    Substring$1(startIndex: int, length: int): string;
    Split(separator: char[]): string[];
    Split$3(separator: char[], count: int): string[];
    Split$2(separator: char[], options: System.StringSplitOptions): string[];
    Split$5(separator: char[], count: int, options: System.StringSplitOptions): string[];
    Split$4(separator: string[], options: System.StringSplitOptions): string[];
    Split$6(separator: string[], count: int, options: System.StringSplitOptions): string[];
    GetEnumerator(): System.Collections.Generic.IEnumerator$1<char>;
    Contains(part: string): boolean;
    CompareTo(obj: any): int;
    CompareTo$1(other: string): int;
    Equals$1(other: string): boolean;
    Equals$2(value: string, comparisonType: System.StringComparison): boolean;
    Replace$1(searchString: string, replaceString: string): string;
    Replace(searchChar: char, replaceChar: char): string;
    ToCharArray(): char[];
    ToCharArray$1(startIndex: int, length: int): char[];
    Trim$1(trimChars: char[]): string;
    TrimStart(trimChars: char[]): string;
    TrimEnd(trimChars: char[]): string;
}
interface StringConstructor {
    Empty: string;
    Compare(strA: string, strB: string): int;
    Compare$1(strA: string, strB: string, comparisonType: System.StringComparison): int;
    Join(separator: string, value: string[]): string;
    Join$1<T>(T, separator: string, values: System.Collections.Generic.IEnumerable$1<T>): string;
    IsNullOrEmpty(s: string): boolean;
    Concat$1(arg0: any): string;
    Concat$4(arg0: any, arg1: any): string;
    Concat$6(arg0: any, arg1: any, arg2: any): string;
    Concat$2(args: any[]): string;
    Concat$9<T>(T, values: System.Collections.Generic.IEnumerable$1<T>): string;
    Concat(values: System.Collections.Generic.IEnumerable$1<string>): string;
    Concat$5(str0: string, str1: string): string;
    Concat$7(str0: string, str1: string, str2: string): string;
    Concat$8(str0: string, str1: string, str2: string, str3: string): string;
    Concat$3(values: string[]): string;
    Format(format: string, args: any[]): string;
    Format$1(provider: System.IFormatProvider, format: string, args: any[]): string;
    Equals(a: string, b: string, comparisonType: System.StringComparison): boolean;
}
declare module System {
    // System.Action
    export interface Action extends MulticastDelegate { }

    // System.Action<T>
    export interface Action$1<T> extends MulticastDelegate { }

    // System.Action<T1, T2>
    export interface Action$2<T1, T2> extends MulticastDelegate { }

    // System.Action<T1, T2, T3>
    export interface Action$3<T1, T2, T3> extends MulticastDelegate { }

    // System.Action<T1, T2, T3, T4>
    export interface Action$4<T1, T2, T3, T4> extends MulticastDelegate { }

    // System.Action<T1, T2, T3, T4, T5>
    export interface Action$5<T1, T2, T3, T4, T5> extends MulticastDelegate { }

    // System.Action<T1, T2, T3, T4, T5, T6>
    export interface Action$6<T1, T2, T3, T4, T5, T6> extends MulticastDelegate { }

    // System.Action<T1, T2, T3, T4, T5, T6, T7>
    export interface Action$7<T1, T2, T3, T4, T5, T6, T7> extends MulticastDelegate { }

    // System.Action<T1, T2, T3, T4, T5, T6, T7, T8>
    export interface Action$8<T1, T2, T3, T4, T5, T6, T7, T8> extends MulticastDelegate { }

    // System.Func<TResult>
    export interface Func$1<TResult> extends MulticastDelegate { }

    // System.Func<T1, TResult>
    export interface Func$2<T1, TResult> extends MulticastDelegate { }

    // System.Func<T1, T2, TResult>
    export interface Func$3<T1, T2, TResult> extends MulticastDelegate { }

    // System.Func<T1, T2, T3, TResult>
    export interface Func$4<T1, T2, T3, TResult> extends MulticastDelegate { }

    // System.Func<T1, T2, T3, T4, TResult>
    export interface Func$5<T1, T2, T3, T4, TResult> extends MulticastDelegate { }

    // System.Func<T1, T2, T3, T4, T5, TResult>
    export interface Func$6<T1, T2, T3, T4, T5, TResult> extends MulticastDelegate { }

    // System.Func<T1, T2, T3, T4, T5, T6, TResult>
    export interface Func$7<T1, T2, T3, T4, T5, T6, TResult> extends MulticastDelegate { }

    // System.Func<T1, T2, T3, T4, T5, T6, T7, TResult>
    export interface Func$8<T1, T2, T3, T4, T5, T6, T7, TResult> extends MulticastDelegate { }

    // System.Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>
    export interface Func$9<T1, T2, T3, T4, T5, T6, T7, T8, TResult> extends MulticastDelegate { }

    // System.Comparison<T>
    export interface Comparison$1<T> extends MulticastDelegate { }

    // System.Converter<TInput, TOutput>
    export interface Converter$2<TInput, TOutput> extends MulticastDelegate { }

    // System.Predicate<T>
    export interface Predicate$1<T> extends MulticastDelegate { }

    // System.AggregateException
    export interface AggregateException extends Exception {
        get_InnerExceptions(): Collections.Generic.List$1<Exception>;
        Handle(predicate: Func$2<Exception, boolean>): void;
        Flatten(): AggregateException;
    }
    export interface AggregateExceptionTypeFunc extends TypeFunction {
        prototype: AggregateException;
        ctor: { new (): AggregateException };
        ctor$3: { new (message: string): AggregateException };
        ctor$5: { new (message: string, innerException: Exception): AggregateException };
        ctor$1: { new (innerExceptions: Collections.Generic.IEnumerable$1<Exception>): AggregateException };
        ctor$2: { new (innerExceptions: Exception[]): AggregateException };
        ctor$4: { new (message: string, innerExceptions: Collections.Generic.IEnumerable$1<Exception>): AggregateException };
        ctor$6: { new (message: string, innerExceptions: Exception[]): AggregateException };
    }
    var AggregateException: AggregateExceptionTypeFunc;

    // System.AppDomain
    export interface AppDomain extends Object {
        GetAssemblies(): Reflection.Assembly[];
    }
    export interface AppDomainTypeFunc extends TypeFunction {
        prototype: AppDomain;
        ctor: { new (): AppDomain };
        get_CurrentDomain(): AppDomain;
    }
    var AppDomain: AppDomainTypeFunc;

    // System.ArgumentException
    export interface ArgumentException extends SystemException {
        get_ParamName(): string;
    }
    export interface ArgumentExceptionTypeFunc extends TypeFunction {
        prototype: ArgumentException;
        ctor: { new (): ArgumentException };
        ctor$1: { new (message: string): ArgumentException };
        ctor$2: { new (message: string, innerException: Exception): ArgumentException };
        ctor$4: { new (message: string, paramName: string, innerException: Exception): ArgumentException };
        ctor$3: { new (message: string, paramName: string): ArgumentException };
    }
    var ArgumentException: ArgumentExceptionTypeFunc;

    // System.ArgumentNullException
    export interface ArgumentNullException extends ArgumentException {
    }
    export interface ArgumentNullExceptionTypeFunc extends TypeFunction {
        prototype: ArgumentNullException;
        ctor: { new (): ArgumentNullException };
        ctor$1: { new (paramName: string): ArgumentNullException };
        ctor$2: { new (message: string, innerException: Exception): ArgumentNullException };
        ctor$3: { new (paramName: string, message: string): ArgumentNullException };
    }
    var ArgumentNullException: ArgumentNullExceptionTypeFunc;

    // System.ArgumentOutOfRangeException
    export interface ArgumentOutOfRangeException extends ArgumentException {
        get_ActualValue(): any;
    }
    export interface ArgumentOutOfRangeExceptionTypeFunc extends TypeFunction {
        prototype: ArgumentOutOfRangeException;
        ctor: { new (): ArgumentOutOfRangeException };
        ctor$1: { new (paramName: string): ArgumentOutOfRangeException };
        ctor$3: { new (paramName: string, message: string): ArgumentOutOfRangeException };
        ctor$2: { new (message: string, innerException: Exception): ArgumentOutOfRangeException };
        ctor$4: { new (paramName: string, actualValue: any, message: string): ArgumentOutOfRangeException };
    }
    var ArgumentOutOfRangeException: ArgumentOutOfRangeExceptionTypeFunc;

    // System.ArithmeticException
    export interface ArithmeticException extends SystemException {
    }
    export interface ArithmeticExceptionTypeFunc extends TypeFunction {
        prototype: ArithmeticException;
        ctor: { new (): ArithmeticException };
        ctor$1: { new (message: string): ArithmeticException };
        ctor$2: { new (message: string, innerException: Exception): ArithmeticException };
    }
    var ArithmeticException: ArithmeticExceptionTypeFunc;

    // System.Attribute
    export interface Attribute extends Object {
    }
    export interface AttributeTypeFunc extends TypeFunction {
        prototype: Attribute;
        IsDefined(element: Reflection.MemberInfo, attributeType: Type): boolean;
        IsDefined$1(element: Reflection.MemberInfo, attributeType: Type, inherit: boolean): boolean;
    }
    var Attribute: AttributeTypeFunc;

    // System.AttributeTargets
    export enum AttributeTargets {
        Assembly = 1,
        Module = 2,
        Class = 4,
        Struct = 8,
        Enum = 16,
        Constructor = 32,
        Method = 64,
        Property = 128,
        Field = 256,
        Event = 512,
        Interface = 1024,
        Parameter = 2048,
        Delegate = 4096,
        ReturnValue = 8192,
        GenericParameter = 16384,
        All = 32767
    }

    // System.AttributeUsageAttribute
    export interface AttributeUsageAttribute extends Attribute {
        get_ValidOn(): AttributeTargets;
        get_AllowMultiple(): boolean;
        set_AllowMultiple(value: boolean): void;
        get_Inherited(): boolean;
        set_Inherited(value: boolean): void;
    }
    export interface AttributeUsageAttributeTypeFunc extends TypeFunction {
        prototype: AttributeUsageAttribute;
        ctor: { new (validOn: AttributeTargets): AttributeUsageAttribute };
    }
    var AttributeUsageAttribute: AttributeUsageAttributeTypeFunc;

    // byte
    export interface Byte extends ValueType, IComparable, IComparable$1<Byte>, IEquatable$1<Byte>, IFormattable {
        CompareTo(value: Object | byte): int;
        Equals(value: Object | byte): boolean;
        ToString$1(format: string): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
    }
    export interface ByteTypeFunc extends TypeFunction {
        prototype: Byte;
        MinValue: byte;
        MaxValue: byte;
        Parse(s: string): byte;
        TryParse(s: string, result: byte): boolean;
    }
    var Byte: ByteTypeFunc;

    // char
    export interface Char extends ValueType, IComparable, IComparable$1<Char>, IEquatable$1<Char> {
        CompareTo(value: Object | char): int;
        Equals(value: Object | char): boolean;
    }
    export interface CharTypeFunc extends TypeFunction {
        prototype: Char;
        MinValue: char;
        MaxValue: char;
        IsLetter(c: char): boolean;
        IsWhiteSpace(c: char): boolean;
        IsDigit(c: char): boolean;
        ToUpper(c: char): char;
        ToLower(c: char): char;
        IsUpper(c: char): boolean;
        IsLower(c: char): boolean;
        Parse(s: string): char;
        TryParse(s: string, result: char): boolean;
    }
    var Char: CharTypeFunc;

    // System.Console
    export interface ConsoleTypeFunc extends TypeFunction {
        Write(value: boolean): void;
        Write$1(value: char): void;
        Write$2(buffer: char[]): void;
        Write$3(value: decimal): void;
        Write$4(value: double): void;
        Write$5(value: float): void;
        Write$6(value: int): void;
        Write$7(value: long): void;
        Write$8(value: any): void;
        Write$9(value: string): void;
        Write$10(value: uint): void;
        Write$11(value: ulong): void;
        Write$12(format: string, arg0: any): void;
        Write$13(format: string, arg: any[]): void;
        Write$14(buffer: char[], index: int, count: int): void;
        Write$15(format: string, arg0: any, arg1: any): void;
        Write$16(format: string, arg0: any, arg1: any, arg2: any): void;
        Write$17(format: string, arg0: any, arg1: any, arg2: any, arg3: any): void;
        WriteLine(): void;
        WriteLine$1(value: boolean): void;
        WriteLine$2(value: char): void;
        WriteLine$3(buffer: char[]): void;
        WriteLine$4(value: decimal): void;
        WriteLine$5(value: double): void;
        WriteLine$6(value: float): void;
        WriteLine$7(value: int): void;
        WriteLine$8(value: long): void;
        WriteLine$9(value: any): void;
        WriteLine$10(value: string): void;
        WriteLine$11(value: uint): void;
        WriteLine$12(value: ulong): void;
        WriteLine$13(format: string, arg0: any): void;
        WriteLine$14(format: string, arg: any[]): void;
        WriteLine$15(buffer: char[], index: int, count: int): void;
        WriteLine$16(format: string, arg0: any, arg1: any): void;
        WriteLine$17(format: string, arg0: any, arg1: any, arg2: any): void;
        WriteLine$18(format: string, arg0: any, arg1: any, arg2: any, arg3: any): void;
    }
    var Console: ConsoleTypeFunc;

    // System.Convert
    export interface ConvertTypeFunc extends TypeFunction {
        ChangeType(value: any, conversionType: Type): any;
    }
    var Convert: ConvertTypeFunc;

    // System.DateTime
    export interface DateTime extends ValueType, IComparable, IFormattable, IConvertible, IComparable$1<DateTime>, IEquatable$1<DateTime> {
        get_JsDate(): Date;
        get_Date(): Date;
        get_Day(): int;
        get_DayOfWeek(): DayOfWeek;
        get_DayOfYear(): int;
        get_Hour(): int;
        get_Kind(): DateTimeKind;
        get_Millisecond(): int;
        get_Minute(): int;
        get_Month(): int;
        get_Second(): int;
        get_Year(): int;
        CompareTo(other: Date): int;
        CompareTo$1(obj: any): int;
        GetTypeCode(): TypeCode;
        Equals$1(other: Date): boolean;
        ToDateTime(provider: IFormatProvider): Date;
        ToString$1(provider: IFormatProvider): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
        Add(value: TimeSpan): Date;
        AddTicks(value: long): Date;
        AddYears(value: int): Date;
        AddMonths(months: int): Date;
        AddDays(value: double): Date;
        AddHours(value: double): Date;
        AddMilliseconds(value: double): Date;
        AddMinutes(value: double): Date;
        AddSeconds(value: double): Date;
    }
    export interface DateTimeTypeFunc extends TypeFunction {
        prototype: DateTime;
        MinValue: Date;
        MaxValue: Date;
        ctor$1: { new (value: Date, kind: DateTimeKind): Date };
        ctor$2: { new (year: int, month: int, day: int): Date };
        ctor$3: { new (year: int, month: int, day: int, hour: int, minute: int, second: int): Date };
        ctor$4: { new (year: int, month: int, day: int, hour: int, minute: int, second: int, kind: DateTimeKind): Date };
        ctor$5: { new (year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): Date };
        ctor$6: { new (year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, kind: DateTimeKind): Date };
        ctor: { new (): Date };
        get_Now(): Date;
        get_UtcNow(): Date;
        get_Today(): Date;
        SpecifyKind(value: Date, kind: DateTimeKind): Date;
        op_Subtraction(left: Date, right: Date): TimeSpan;
    }
    var DateTime: DateTimeTypeFunc;

    // System.DateTimeKind
    export enum DateTimeKind {
        Unspecified = 0,
        Utc = 1,
        Local = 2
    }

    // System.DayOfWeek
    export enum DayOfWeek {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6
    }

    // decimal
    export interface Decimal extends ValueType, IComparable, IComparable$1<Decimal>, IEquatable$1<Decimal> {
        CompareTo(value: Object | decimal): int;
        Equals(value: Object | decimal): boolean;
        ToString$1(format: string): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
    }
    export interface DecimalTypeFunc extends TypeFunction {
        prototype: Decimal;
    }
    var Decimal: DecimalTypeFunc;

    // System.Delegate
    export interface Delegate extends Function {
        get_Method(): Function;
        get_Target(): any;
        GetInvocationList(): Delegate[];
        DynamicInvoke(args: any[]): any;
    }
    export interface DelegateTypeFunc extends TypeFunction {
        prototype: Delegate;
        Combine(a: Delegate, b: Delegate): Delegate;
        Remove(source: Delegate, value: Delegate): Delegate;
        RemoveAll(source: Delegate, value: Delegate): Delegate;
        op_Equality(d1: Delegate, d2: Delegate): boolean;
        op_Inequality(d1: Delegate, d2: Delegate): boolean;
    }
    var Delegate: DelegateTypeFunc;

    // double
    export interface Double extends ValueType, IComparable, IComparable$1<Double>, IEquatable$1<Double>, IFormattable {
        CompareTo(value: Object | double): int;
        Equals(value: Object | double): boolean;
        ToString$1(format: string): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
    }
    export interface DoubleTypeFunc extends TypeFunction {
        prototype: Double;
        MinValue: double;
        MaxValue: double;
        Epsilon: double;
        NaN: double;
        NegativeInfinity: double;
        PositiveInfinity: double;
        Parse(s: string): double;
        TryParse(s: string, result: double): boolean;
        IsNaN(d: double): boolean;
        IsInfinity(d: double): boolean;
        IsNegativeInfinity(d: double): boolean;
        IsPositiveInfinity(d: double): boolean;
    }
    var Double: DoubleTypeFunc;

    // System.Enum
    export interface Enum extends ValueType, IComparable {
        CompareTo(target: any): int;
        GetTypeCode(): TypeCode;
        HasFlag(flag: Enum): boolean;
    }
    export interface EnumTypeFunc extends TypeFunction {
        prototype: Enum;
        Parse(enumType: Type, value: string): any;
        Parse$1(enumType: Type, value: string, ignoreCase: boolean): any;
        TryParse<TEnum>(TEnum, value: string, result: TEnum): boolean;
        TryParse$1<TEnum>(TEnum, value: string, ignoreCase: boolean, result: TEnum): boolean;
        ToObject<T>(T, enumType: Type, value: T): any;
        GetNames(enumType: Type): string[];
        GetValues(enumType: Type): Array<any>;
        GetUnderlyingType(enumType: Type): Type;
    }
    var Enum: EnumTypeFunc;

    // System.Environment
    export interface EnvironmentTypeFunc extends TypeFunction {
        NewLine: string;
        get_CurrentManagedThreadId(): int;
        get_TickCount(): int;
    }
    var Environment: EnvironmentTypeFunc;

    // System.EventArgs
    export interface EventArgs extends Object {
    }
    export interface EventArgsTypeFunc extends TypeFunction {
        prototype: EventArgs;
        Empty: EventArgs;
        ctor: { new (): EventArgs };
    }
    var EventArgs: EventArgsTypeFunc;

    // System.EventHandler
    export interface EventHandler extends MulticastDelegate { }

    // System.EventHandler<TEventArgs>
    export interface EventHandler$1<TEventArgs> extends MulticastDelegate { }

    // System.Exception
    export interface Exception extends Object {
        get_Data(): Collections.IDictionary;
        get_InnerException(): Exception;
        get_Message(): string;
        get_StackTrace(): string;
        GetBaseException(): Exception;
    }
    export interface ExceptionTypeFunc extends TypeFunction {
        prototype: Exception;
        ctor: { new (): Exception };
        ctor$1: { new (message: string): Exception };
        ctor$2: { new (message: string, innerException: Exception): Exception };
        Wrap(e: Exception): Exception;
    }
    var Exception: ExceptionTypeFunc;

    // System.FlagsAttribute
    export interface FlagsAttribute extends Attribute {
    }
    export interface FlagsAttributeTypeFunc extends TypeFunction {
        prototype: FlagsAttribute;
        ctor: { new (): FlagsAttribute };
    }
    var FlagsAttribute: FlagsAttributeTypeFunc;

    // System.FormatException
    export interface FormatException extends Exception {
    }
    export interface FormatExceptionTypeFunc extends TypeFunction {
        prototype: FormatException;
        ctor: { new (): FormatException };
        ctor$1: { new (message: string): FormatException };
        ctor$2: { new (message: string, innerException: Exception): FormatException };
    }
    var FormatException: FormatExceptionTypeFunc;

    // System.GC
    export interface GCTypeFunc extends TypeFunction {
        KeepAlive(obj: any): void;
        SuppressFinalize(obj: any): void;
    }
    var GC: GCTypeFunc;

    // System.Guid
    export interface Guid extends ValueType, IFormattable, IComparable, IComparable$1<Guid>, IEquatable$1<Guid> {
        CompareTo$1(obj: any): int;
        CompareTo(other: Guid): int;
        Equals$1(other: Guid): boolean;
        ToByteArray(): byte[];
        ToString$1(format: string): string;
        ToString$2(format: string, provider: IFormatProvider): string;
    }
    export interface GuidTypeFunc extends TypeFunction {
        prototype: Guid;
        Empty: Guid;
        ctor$1: { new (b: byte[]): Guid };
        ctor: { new (): Guid };
        NewGuid(): Guid;
        Parse(input: string): Guid;
        ParseExact(input: string, format: string): Guid;
        TryParse(input: string, result: Guid): boolean;
        TryParseExact(input: string, format: string, result: Guid): boolean;
    }
    var Guid: GuidTypeFunc;

    // System.IComparable
    export interface IComparable {
        System$IComparable$CompareTo(obj: any): int;
    }
    var IComparable: TypeFunction;

    // System.IComparable<T>
    export interface IComparable$1<T> {
        System$IComparable$1$CompareTo(other: T): int;
    }
    var IComparable$1: TypeFunction;

    // System.IConvertible
    export interface IConvertible {
        System$IConvertible$GetTypeCode(): TypeCode;
        System$IConvertible$ToBoolean(provider: IFormatProvider): boolean;
        System$IConvertible$ToChar(provider: IFormatProvider): char;
        System$IConvertible$ToSByte(provider: IFormatProvider): sbyte;
        System$IConvertible$ToByte(provider: IFormatProvider): byte;
        System$IConvertible$ToInt16(provider: IFormatProvider): short;
        System$IConvertible$ToUInt16(provider: IFormatProvider): ushort;
        System$IConvertible$ToInt32(provider: IFormatProvider): int;
        System$IConvertible$ToUInt32(provider: IFormatProvider): uint;
        System$IConvertible$ToInt64(provider: IFormatProvider): long;
        System$IConvertible$ToUInt64(provider: IFormatProvider): ulong;
        System$IConvertible$ToSingle(provider: IFormatProvider): float;
        System$IConvertible$ToDouble(provider: IFormatProvider): double;
        System$IConvertible$ToDecimal(provider: IFormatProvider): decimal;
        System$IConvertible$ToDateTime(provider: IFormatProvider): Date;
        System$IConvertible$ToString(provider: IFormatProvider): string;
        System$IConvertible$ToType(conversionType: Type, provider: IFormatProvider): any;
    }
    var IConvertible: TypeFunction;

    // System.ICustomFormatter
    export interface ICustomFormatter {
        System$ICustomFormatter$Format(format: string, arg: any, formatProvider: IFormatProvider): string;
    }
    var ICustomFormatter: TypeFunction;

    // System.IDisposable
    export interface IDisposable {
        System$IDisposable$Dispose(): void;
    }
    var IDisposable: TypeFunction;

    // System.IEquatable<T>
    export interface IEquatable$1<T> {
        System$IEquatable$1$Equals(other: T): boolean;
    }
    var IEquatable$1: TypeFunction;

    // System.IFormatProvider
    export interface IFormatProvider {
        System$IFormatProvider$GetFormat(formatType: Type): any;
    }
    var IFormatProvider: TypeFunction;

    // System.IFormattable
    export interface IFormattable {
        System$IFormattable$ToString(format: string, formatProvider: IFormatProvider): string;
    }
    var IFormattable: TypeFunction;

    // System.IndexOutOfRangeException
    export interface IndexOutOfRangeException extends SystemException {
    }
    export interface IndexOutOfRangeExceptionTypeFunc extends TypeFunction {
        prototype: IndexOutOfRangeException;
        ctor: { new (): IndexOutOfRangeException };
        ctor$1: { new (message: string): IndexOutOfRangeException };
        ctor$2: { new (message: string, innerException: Exception): IndexOutOfRangeException };
    }
    var IndexOutOfRangeException: IndexOutOfRangeExceptionTypeFunc;

    // short
    export interface Int16 extends ValueType, IComparable, IComparable$1<Int16>, IEquatable$1<Int16>, IFormattable {
        CompareTo(value: Object | short): int;
        Equals(value: Object | short): boolean;
        ToString$1(format: string): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
    }
    export interface Int16TypeFunc extends TypeFunction {
        prototype: Int16;
        MaxValue: short;
        MinValue: short;
        Parse(s: string): short;
        TryParse(s: string, result: short): boolean;
    }
    var Int16: Int16TypeFunc;

    // int
    export interface Int32 extends ValueType, IComparable, IComparable$1<Int32>, IEquatable$1<Int32>, IFormattable {
        CompareTo(value: Object | int): int;
        Equals(value: Object | int): boolean;
        ToString$1(format: string): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
    }
    export interface Int32TypeFunc extends TypeFunction {
        prototype: Int32;
        MaxValue: int;
        MinValue: int;
        Parse(s: string): int;
        TryParse(s: string, result: int): boolean;
    }
    var Int32: Int32TypeFunc;

    // long
    export interface Int64 extends ValueType, IComparable, IComparable$1<Int64>, IEquatable$1<Int64>, IFormattable {
        CompareTo(value: Object | long): int;
        Equals(value: Object | long): boolean;
        ToString$1(format: string): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
    }
    export interface Int64TypeFunc extends TypeFunction {
        prototype: Int64;
        MinValue: long;
        MaxValue: long;
        Parse(s: string): long;
        TryParse(s: string, result: long): boolean;
    }
    var Int64: Int64TypeFunc;

    // System.InvalidCastException
    export interface InvalidCastException extends Exception {
    }
    export interface InvalidCastExceptionTypeFunc extends TypeFunction {
        prototype: InvalidCastException;
        ctor: { new (message: string): InvalidCastException };
    }
    var InvalidCastException: InvalidCastExceptionTypeFunc;

    // System.InvalidOperationException
    export interface InvalidOperationException extends Exception {
    }
    export interface InvalidOperationExceptionTypeFunc extends TypeFunction {
        prototype: InvalidOperationException;
        ctor: { new (): InvalidOperationException };
        ctor$1: { new (message: string): InvalidOperationException };
        ctor$2: { new (message: string, innerException: Exception): InvalidOperationException };
    }
    var InvalidOperationException: InvalidOperationExceptionTypeFunc;

    // System.IObservable<T>
    export interface IObservable$1<T> {
        System$IObservable$1$Subscribe(observer: IObserver$1<T>): IDisposable;
    }
    var IObservable$1: TypeFunction;

    // System.IObserver<T>
    export interface IObserver$1<T> {
        System$IObserver$1$OnNext(value: T): void;
        System$IObserver$1$OnError(error: Exception): void;
        System$IObserver$1$OnCompleted(): void;
    }
    var IObserver$1: TypeFunction;

    // System.IServiceProvider
    export interface IServiceProvider {
        System$IServiceProvider$GetService(serviceType: Type): any;
    }
    var IServiceProvider: TypeFunction;

    // System.LazyThreadSafetyMode
    export enum LazyThreadSafetyMode {
        ExecutionAndPublication = 0
    }

    // System.Lazy<T>
    export interface Lazy$1<T> extends Object {
        get_IsValueCreated(): boolean;
        get_Value(): T;
    }
    export interface Lazy$1TypeFunc<T> extends TypeFunction {
        (T): {
            prototype: Lazy$1<T>;
            ctor: { new (): Lazy$1<T> };
            ctor$1: { new (valueFactory: Func$1<T>): Lazy$1<T> };
            ctor$2: { new (mode: LazyThreadSafetyMode): Lazy$1<T> };
            ctor$3: { new (valueFactory: Func$1<T>, mode: LazyThreadSafetyMode): Lazy$1<T> };
        }
    }
    var Lazy$1: Lazy$1TypeFunc<any>;

    // System.Math
    export interface MathTypeFunc extends TypeFunction {
        PI: double;
        E: double;
        Acos(d: double): double;
        Asin(d: double): double;
        Atan(d: double): double;
        Atan2(y: double, x: double): double;
        Ceiling(d: decimal): decimal;
        Ceiling$1(a: double): double;
        Cos(d: double): double;
        Cosh(value: double): double;
        Floor(d: decimal): decimal;
        Floor$1(d: double): double;
        Exp(d: double): double;
        Pow(exponentBase: double, exponent: double): double;
        Sin(a: double): double;
        Tan(a: double): double;
        Sinh(value: double): double;
        Tanh(value: double): double;
        Round(a: double): double;
        Sqrt(d: double): double;
        Round$1(value: double, digits: int): double;
        Truncate(value: double): double;
        Abs(value: double): double;
        Round$2(value: double, digits: int, mode: MidpointRounding): double;
        Sign(value: double): int;
        Max(val1: int, val2: int): int;
        Max$1(val1: double, val2: double): double;
        Min(val1: int, val2: int): int;
        Min$1(val1: double, val2: double): double;
        Log(d: double): double;
        Log10(d: double): double;
        Log$1(a: double, newBase: double): double;
    }
    var Math: MathTypeFunc;

    // System.NotImplementedException
    export interface NotImplementedException extends Exception {
    }
    export interface NotImplementedExceptionTypeFunc extends TypeFunction {
        prototype: NotImplementedException;
        ctor: { new (): NotImplementedException };
        ctor$1: { new (message: string): NotImplementedException };
        ctor$2: { new (message: string, innerException: Exception): NotImplementedException };
    }
    var NotImplementedException: NotImplementedExceptionTypeFunc;

    // System.NotSupportedException
    export interface NotSupportedException extends Exception {
    }
    export interface NotSupportedExceptionTypeFunc extends TypeFunction {
        prototype: NotSupportedException;
        ctor: { new (): NotSupportedException };
        ctor$1: { new (message: string): NotSupportedException };
        ctor$2: { new (message: string, innerException: Exception): NotSupportedException };
    }
    var NotSupportedException: NotSupportedExceptionTypeFunc;

    // System.Nullable<T>
    export interface Nullable$1<T> extends ValueType {
    }
    export interface Nullable$1TypeFunc<T> extends TypeFunction {
        (T): {
            prototype: Nullable$1<T>;
            ctor: { new (): Nullable$1<T> };
        }
    }
    var Nullable$1: Nullable$1TypeFunc<any>;

    // System.NullReferenceException
    export interface NullReferenceException extends SystemException {
    }
    export interface NullReferenceExceptionTypeFunc extends TypeFunction {
        prototype: NullReferenceException;
        ctor: { new (): NullReferenceException };
        ctor$1: { new (message: string): NullReferenceException };
        ctor$2: { new (message: string, innerException: Exception): NullReferenceException };
    }
    var NullReferenceException: NullReferenceExceptionTypeFunc;

    // System.ObjectDisposedException
    export interface ObjectDisposedException extends Exception {
    }
    export interface ObjectDisposedExceptionTypeFunc extends TypeFunction {
        prototype: ObjectDisposedException;
        ctor: { new (): ObjectDisposedException };
        ctor$1: { new (message: string): ObjectDisposedException };
        ctor$3: { new (objectName: string, message: string): ObjectDisposedException };
        ctor$2: { new (message: string, innerException: Exception): ObjectDisposedException };
    }
    var ObjectDisposedException: ObjectDisposedExceptionTypeFunc;

    // System.OverflowException
    export interface OverflowException extends ArithmeticException {
    }
    export interface OverflowExceptionTypeFunc extends TypeFunction {
        prototype: OverflowException;
        ctor: { new (): OverflowException };
        ctor$1: { new (message: string): OverflowException };
        ctor$2: { new (message: string, innerException: Exception): OverflowException };
    }
    var OverflowException: OverflowExceptionTypeFunc;

    // System.Random
    export interface Random extends Object {
        Next(): int;
        Next$2(minValue: int, maxValue: int): int;
        Next$1(maxValue: int): int;
        NextDouble(): double;
        NextBytes(buffer: byte[]): void;
    }
    export interface RandomTypeFunc extends TypeFunction {
        prototype: Random;
        ctor: { new (): Random };
        ctor$1: { new (seed: int): Random };
    }
    var Random: RandomTypeFunc;

    // System.Activator
    export interface ActivatorTypeFunc extends TypeFunction {
        CreateInstance$3(type: Type, bindingAttr: Reflection.BindingFlags, binder: Reflection.Binder, args: any[], culture: Globalization.CultureInfo): any;
        CreateInstance$2(type: Type, args: any[]): any;
        CreateInstance(type: Type): any;
        CreateInstance$1(type: Type, nonPublic: boolean): any;
        CreateInstance$4<T>(T): T;
    }
    var Activator: ActivatorTypeFunc;

    // System.IntPtr
    export interface IntPtr extends ValueType {
    }
    export interface IntPtrTypeFunc extends TypeFunction {
        prototype: IntPtr;
        ctor: { new (): IntPtr };
    }
    var IntPtr: IntPtrTypeFunc;

    // System.MulticastDelegate
    export interface MulticastDelegate extends Delegate {
    }
    export interface MulticastDelegateTypeFunc extends TypeFunction {
        prototype: MulticastDelegate;
    }
    var MulticastDelegate: MulticastDelegateTypeFunc;

    // object
    export interface Object {
        GetType(): Type;
        ToString(): string;
        Equals(obj: any): boolean;
        GetHashCode(): int;
    }
    export interface ObjectTypeFunc extends TypeFunction {
        prototype: Object;
        ctor: { new (): any };
        Equals(objA: any, objB: any): boolean;
        ReferenceEquals(objA: any, objB: any): boolean;
    }
    var Object: ObjectTypeFunc;

    // System.MidpointRounding
    export enum MidpointRounding {
        ToEven = 0,
        AwayFromZero = 1
    }

    // sbyte
    export interface SByte extends ValueType, IComparable, IComparable$1<SByte>, IEquatable$1<SByte>, IFormattable {
        CompareTo(value: Object | sbyte): int;
        Equals(value: Object | sbyte): boolean;
        ToString$1(format: string): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
    }
    export interface SByteTypeFunc extends TypeFunction {
        prototype: SByte;
        MinValue: sbyte;
        MaxValue: sbyte;
        Parse(s: string): sbyte;
        TryParse(s: string, result: sbyte): boolean;
    }
    var SByte: SByteTypeFunc;

    // float
    export interface Single extends ValueType, IComparable, IComparable$1<Single>, IEquatable$1<Single>, IFormattable {
        CompareTo(value: Object | float): int;
        Equals(value: Object | float): boolean;
        ToString$1(format: string): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
    }
    export interface SingleTypeFunc extends TypeFunction {
        prototype: Single;
        MinValue: float;
        Epsilon: float;
        MaxValue: float;
        NaN: float;
        NegativeInfinity: float;
        PositiveInfinity: float;
        Parse(s: string): float;
        TryParse(s: string, result: float): boolean;
        IsNaN(f: float): boolean;
        IsInfinity(f: float): boolean;
        IsNegativeInfinity(f: float): boolean;
        IsPositiveInfinity(f: float): boolean;
    }
    var Single: SingleTypeFunc;

    // System.Stopwatch
    export interface Stopwatch extends Object {
        Start(): void;
        Stop(): void;
        Reset(): void;
        Restart(): void;
        get_IsRunning(): boolean;
        get_Elapsed(): TimeSpan;
        get_ElapsedMilliseconds(): long;
        get_ElapsedTicks(): long;
    }
    export interface StopwatchTypeFunc extends TypeFunction {
        prototype: Stopwatch;
        Frequency: long;
        IsHighResolution: boolean;
        ctor: { new (): Stopwatch };
        StartNew(): Stopwatch;
        GetTimestamp(): long;
    }
    var Stopwatch: StopwatchTypeFunc;

    // System.StringComparison
    export enum StringComparison {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5
    }

    // System.StringSplitOptions
    export enum StringSplitOptions {
        None = 0,
        RemoveEmptyEntries = 1
    }

    // System.SystemException
    export interface SystemException extends Exception {
    }
    export interface SystemExceptionTypeFunc extends TypeFunction {
        prototype: SystemException;
        ctor: { new (): SystemException };
        ctor$1: { new (message: string): SystemException };
        ctor$2: { new (message: string, innerException: Exception): SystemException };
    }
    var SystemException: SystemExceptionTypeFunc;

    // System.TimeSpan
    export interface TimeSpan extends ValueType {
        get_Ticks(): long;
        get_Days(): int;
        get_Hours(): int;
        get_Milliseconds(): int;
        get_Minutes(): int;
        get_Seconds(): int;
        get_TotalDays(): double;
        get_TotalHours(): double;
        get_TotalMilliseconds(): double;
        get_TotalMinutes(): double;
        get_TotalSeconds(): double;
        Add(ts: TimeSpan): TimeSpan;
        Subtract(ts: TimeSpan): TimeSpan;
        Equals$1(obj: TimeSpan): boolean;
        Duration(): TimeSpan;
        CompareTo(value: TimeSpan): int;
        CompareTo$1(value: any): int;
    }
    export interface TimeSpanTypeFunc extends TypeFunction {
        prototype: TimeSpan;
        Zero: TimeSpan;
        MaxValue: TimeSpan;
        MinValue: TimeSpan;
        TicksPerMillisecond: long;
        TicksPerSecond: long;
        TicksPerMinute: long;
        TicksPerHour: long;
        TicksPerDay: long;
        ctor$1: { new (ticks: long): TimeSpan };
        ctor$2: { new (hours: int, minutes: int, seconds: int): TimeSpan };
        ctor$3: { new (days: int, hours: int, minutes: int, seconds: int): TimeSpan };
        ctor$4: { new (days: int, hours: int, minutes: int, seconds: int, milliseconds: int): TimeSpan };
        ctor: { new (): TimeSpan };
        FromTicks(value: long): TimeSpan;
        FromSeconds(value: double): TimeSpan;
        FromHours(value: double): TimeSpan;
        FromDays(value: double): TimeSpan;
        FromMilliseconds(value: double): TimeSpan;
        FromMinutes(value: double): TimeSpan;
        Equals(t1: TimeSpan, t2: TimeSpan): boolean;
        Compare(t1: TimeSpan, t2: TimeSpan): int;
        op_UnaryNegation(t: TimeSpan): TimeSpan;
        op_Subtraction(t1: TimeSpan, t2: TimeSpan): TimeSpan;
        op_UnaryPlus(t: TimeSpan): TimeSpan;
        op_Addition(t1: TimeSpan, t2: TimeSpan): TimeSpan;
        op_Equality(t1: TimeSpan, t2: TimeSpan): boolean;
        op_Inequality(t1: TimeSpan, t2: TimeSpan): boolean;
        op_LessThan(t1: TimeSpan, t2: TimeSpan): boolean;
        op_LessThanOrEqual(t1: TimeSpan, t2: TimeSpan): boolean;
        op_GreaterThan(t1: TimeSpan, t2: TimeSpan): boolean;
        op_GreaterThanOrEqual(t1: TimeSpan, t2: TimeSpan): boolean;
    }
    var TimeSpan: TimeSpanTypeFunc;

    // System.Tuple
    export interface TupleTypeFunc extends TypeFunction {
        Create<T1>(T1, item1: T1): Tuple$1<T1>;
        Create$1<T1, T2>(T1, T2, item1: T1, item2: T2): Tuple$2<T1, T2>;
        Create$2<T1, T2, T3>(T1, T2, T3, item1: T1, item2: T2, item3: T3): Tuple$3<T1, T2, T3>;
        Create$3<T1, T2, T3, T4>(T1, T2, T3, T4, item1: T1, item2: T2, item3: T3, item4: T4): Tuple$4<T1, T2, T3, T4>;
        Create$4<T1, T2, T3, T4, T5>(T1, T2, T3, T4, T5, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5): Tuple$5<T1, T2, T3, T4, T5>;
        Create$5<T1, T2, T3, T4, T5, T6>(T1, T2, T3, T4, T5, T6, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6): Tuple$6<T1, T2, T3, T4, T5, T6>;
        Create$6<T1, T2, T3, T4, T5, T6, T7>(T1, T2, T3, T4, T5, T6, T7, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7): Tuple$7<T1, T2, T3, T4, T5, T6, T7>;
        Create$7<T1, T2, T3, T4, T5, T6, T7, T8>(T1, T2, T3, T4, T5, T6, T7, T8, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8): Tuple$8<T1, T2, T3, T4, T5, T6, T7, Tuple$1<T8>>;
    }
    var Tuple: TupleTypeFunc;

    // System.Tuple<T1>
    export interface Tuple$1<T1> extends Object, Collections.IStructuralEquatable, Collections.IStructuralComparable, IComparable {
        get_Item1(): T1;
    }
    export interface Tuple$1TypeFunc<T1> extends TypeFunction {
        (T1): {
            prototype: Tuple$1<T1>;
            ctor: { new (item1: T1): Tuple$1<T1> };
        }
    }
    var Tuple$1: Tuple$1TypeFunc<any>;

    // System.Tuple<T1, T2>
    export interface Tuple$2<T1, T2> extends Object, Collections.IStructuralEquatable, Collections.IStructuralComparable, IComparable {
        get_Item1(): T1;
        get_Item2(): T2;
    }
    export interface Tuple$2TypeFunc<T1, T2> extends TypeFunction {
        (T1, T2): {
            prototype: Tuple$2<T1, T2>;
            ctor: { new (item1: T1, item2: T2): Tuple$2<T1, T2> };
        }
    }
    var Tuple$2: Tuple$2TypeFunc<any, any>;

    // System.Tuple<T1, T2, T3>
    export interface Tuple$3<T1, T2, T3> extends Object, Collections.IStructuralEquatable, Collections.IStructuralComparable, IComparable {
        get_Item1(): T1;
        get_Item2(): T2;
        get_Item3(): T3;
    }
    export interface Tuple$3TypeFunc<T1, T2, T3> extends TypeFunction {
        (T1, T2, T3): {
            prototype: Tuple$3<T1, T2, T3>;
            ctor: { new (item1: T1, item2: T2, item3: T3): Tuple$3<T1, T2, T3> };
        }
    }
    var Tuple$3: Tuple$3TypeFunc<any, any, any>;

    // System.Tuple<T1, T2, T3, T4>
    export interface Tuple$4<T1, T2, T3, T4> extends Object, Collections.IStructuralEquatable, Collections.IStructuralComparable, IComparable {
        get_Item1(): T1;
        get_Item2(): T2;
        get_Item3(): T3;
        get_Item4(): T4;
    }
    export interface Tuple$4TypeFunc<T1, T2, T3, T4> extends TypeFunction {
        (T1, T2, T3, T4): {
            prototype: Tuple$4<T1, T2, T3, T4>;
            ctor: { new (item1: T1, item2: T2, item3: T3, item4: T4): Tuple$4<T1, T2, T3, T4> };
        }
    }
    var Tuple$4: Tuple$4TypeFunc<any, any, any, any>;

    // System.Tuple<T1, T2, T3, T4, T5>
    export interface Tuple$5<T1, T2, T3, T4, T5> extends Object, Collections.IStructuralEquatable, Collections.IStructuralComparable, IComparable {
        get_Item1(): T1;
        get_Item2(): T2;
        get_Item3(): T3;
        get_Item4(): T4;
        get_Item5(): T5;
    }
    export interface Tuple$5TypeFunc<T1, T2, T3, T4, T5> extends TypeFunction {
        (T1, T2, T3, T4, T5): {
            prototype: Tuple$5<T1, T2, T3, T4, T5>;
            ctor: { new (item1: T1, item2: T2, item3: T3, item4: T4, item5: T5): Tuple$5<T1, T2, T3, T4, T5> };
        }
    }
    var Tuple$5: Tuple$5TypeFunc<any, any, any, any, any>;

    // System.Tuple<T1, T2, T3, T4, T5, T6>
    export interface Tuple$6<T1, T2, T3, T4, T5, T6> extends Object, Collections.IStructuralEquatable, Collections.IStructuralComparable, IComparable {
        get_Item1(): T1;
        get_Item2(): T2;
        get_Item3(): T3;
        get_Item4(): T4;
        get_Item5(): T5;
        get_Item6(): T6;
    }
    export interface Tuple$6TypeFunc<T1, T2, T3, T4, T5, T6> extends TypeFunction {
        (T1, T2, T3, T4, T5, T6): {
            prototype: Tuple$6<T1, T2, T3, T4, T5, T6>;
            ctor: { new (item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6): Tuple$6<T1, T2, T3, T4, T5, T6> };
        }
    }
    var Tuple$6: Tuple$6TypeFunc<any, any, any, any, any, any>;

    // System.Tuple<T1, T2, T3, T4, T5, T6, T7>
    export interface Tuple$7<T1, T2, T3, T4, T5, T6, T7> extends Object, Collections.IStructuralEquatable, Collections.IStructuralComparable, IComparable {
        get_Item1(): T1;
        get_Item2(): T2;
        get_Item3(): T3;
        get_Item4(): T4;
        get_Item5(): T5;
        get_Item6(): T6;
        get_Item7(): T7;
    }
    export interface Tuple$7TypeFunc<T1, T2, T3, T4, T5, T6, T7> extends TypeFunction {
        (T1, T2, T3, T4, T5, T6, T7): {
            prototype: Tuple$7<T1, T2, T3, T4, T5, T6, T7>;
            ctor: { new (item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7): Tuple$7<T1, T2, T3, T4, T5, T6, T7> };
        }
    }
    var Tuple$7: Tuple$7TypeFunc<any, any, any, any, any, any, any>;

    // System.Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>
    export interface Tuple$8<T1, T2, T3, T4, T5, T6, T7, TRest> extends Object, Collections.IStructuralEquatable, Collections.IStructuralComparable, IComparable {
        get_Item1(): T1;
        get_Item2(): T2;
        get_Item3(): T3;
        get_Item4(): T4;
        get_Item5(): T5;
        get_Item6(): T6;
        get_Item7(): T7;
        get_Rest(): TRest;
    }
    export interface Tuple$8TypeFunc<T1, T2, T3, T4, T5, T6, T7, TRest> extends TypeFunction {
        (T1, T2, T3, T4, T5, T6, T7, TRest): {
            prototype: Tuple$8<T1, T2, T3, T4, T5, T6, T7, TRest>;
            ctor: { new (item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, rest: TRest): Tuple$8<T1, T2, T3, T4, T5, T6, T7, TRest> };
        }
    }
    var Tuple$8: Tuple$8TypeFunc<any, any, any, any, any, any, any, any>;

    // System.Type
    export interface Type extends Reflection.MemberInfo, Reflection.ICustomAttributeProvider {
        get_BaseType(): Type;
        get_Assembly(): Reflection.Assembly;
        get_AssemblyQualifiedName(): string;
        get_FullName(): string;
        GetElementType(): Type;
        IsAssignableFrom(type: Type): boolean;
        IsInstanceOfType(o: any): boolean;
        GetInterfaces(): Type[];
        GetProperties(): Reflection.PropertyInfo[];
        GetEvents(): Reflection.EventInfo[];
        GetEvent(name: string): Reflection.EventInfo;
        GetMethods(): Reflection.MethodInfo[];
        GetMethod$2(name: string, types: Type[]): Reflection.MethodInfo;
        GetMethod$1(name: string, bindingAttr: Reflection.BindingFlags): Reflection.MethodInfo;
        GetMethod(name: string): Reflection.MethodInfo;
        GetProperty$6(name: string, bindingAttr: Reflection.BindingFlags, binder: Reflection.Binder, returnType: Type, types: Type[], modifiers: Reflection.ParameterModifier[]): Reflection.PropertyInfo;
        GetProperty$5(name: string, returnType: Type, types: Type[], modifiers: Reflection.ParameterModifier[]): Reflection.PropertyInfo;
        GetProperty$1(name: string, bindingAttr: Reflection.BindingFlags): Reflection.PropertyInfo;
        GetProperty$4(name: string, returnType: Type, types: Type[]): Reflection.PropertyInfo;
        GetProperty$3(name: string, types: Type[]): Reflection.PropertyInfo;
        GetProperty$2(name: string, returnType: Type): Reflection.PropertyInfo;
        GetProperty(name: string): Reflection.PropertyInfo;
        GetConstructors(): Reflection.ConstructorInfo[];
        GetField$1(name: string, bindingAttr: Reflection.BindingFlags): Reflection.FieldInfo;
        GetField(name: string): Reflection.FieldInfo;
        GetFields(): Reflection.FieldInfo[];
        GetFields$1(bindingAttr: Reflection.BindingFlags): Reflection.FieldInfo[];
        get_IsValueType(): boolean;
        GetArrayRank(): int;
        GetConstructor$2(bindingAttr: Reflection.BindingFlags, binder: Reflection.Binder, callConvention: Reflection.CallingConventions, types: Type[], modifiers: Reflection.ParameterModifier[]): Reflection.ConstructorInfo;
        GetConstructor$1(bindingAttr: Reflection.BindingFlags, binder: Reflection.Binder, types: Type[], modifiers: Reflection.ParameterModifier[]): Reflection.ConstructorInfo;
        GetConstructor(types: Type[]): Reflection.ConstructorInfo;
        GetEnumNames(): string[];
        GetEnumValues(): Array<any>;
        GetEnumUnderlyingType(): Type;
        MakeArrayType(): Type;
        MakeArrayType$1(rank: int): Type;
        get_Attributes(): Reflection.TypeAttributes;
        get_IsPrimitive(): boolean;
        get_IsAbstract(): boolean;
        get_IsEnum(): boolean;
        get_IsInterface(): boolean;
        get_IsSealed(): boolean;
        get_IsGenericType(): boolean;
        GetGenericTypeDefinition(): Type;
        MakeGenericType(typeArguments: Type[]): Type;
        get_GenericTypeArguments(): Type[];
        GetGenericArguments(): Type[];
        get_IsArray(): boolean;
        get_IsTypedArrayCompatible(): boolean;
        get_IsGenericTypeDefinition(): boolean;
        get_IsGenericParameter(): boolean;
        get_HasElementType(): boolean;
        get_IsNested(): boolean;
        get_IsNestedPublic(): boolean;
        get_IsVisible(): boolean;
        get_IsPublic(): boolean;
    }
    export interface TypeTypeFunc extends TypeFunction {
        prototype: Type;
        EmptyTypes: Type[];
        DefaultBinder: Reflection.Binder;
        GetType(typeName: string): Type;
    }
    var Type: TypeTypeFunc;

    // System.TypeCode
    export enum TypeCode {
        Empty = 0,
        Object = 1,
        DBNull = 2,
        Boolean = 3,
        Char = 4,
        SByte = 5,
        Byte = 6,
        Int16 = 7,
        UInt16 = 8,
        Int32 = 9,
        UInt32 = 10,
        Int64 = 11,
        UInt64 = 12,
        Single = 13,
        Double = 14,
        Decimal = 15,
        DateTime = 16,
        String = 18
    }

    // ushort
    export interface UInt16 extends ValueType, IComparable, IComparable$1<UInt16>, IEquatable$1<UInt16>, IFormattable {
        CompareTo(value: Object | ushort): int;
        Equals(value: Object | ushort): boolean;
        ToString$1(format: string): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
    }
    export interface UInt16TypeFunc extends TypeFunction {
        prototype: UInt16;
        MinValue: ushort;
        MaxValue: ushort;
        Parse(s: string): ushort;
        TryParse(s: string, result: ushort): boolean;
    }
    var UInt16: UInt16TypeFunc;

    // uint
    export interface UInt32 extends ValueType, IComparable, IComparable$1<UInt32>, IEquatable$1<UInt32>, IFormattable {
        CompareTo(value: Object | uint): int;
        Equals(value: Object | uint): boolean;
        ToString$1(format: string): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
    }
    export interface UInt32TypeFunc extends TypeFunction {
        prototype: UInt32;
        MinValue: uint;
        MaxValue: uint;
        Parse(s: string): uint;
        TryParse(s: string, result: uint): boolean;
    }
    var UInt32: UInt32TypeFunc;

    // ulong
    export interface UInt64 extends ValueType, IComparable, IComparable$1<UInt64>, IEquatable$1<UInt64>, IFormattable {
        CompareTo(value: Object | ulong): int;
        Equals(value: Object | ulong): boolean;
        ToString$1(format: string): string;
        ToString$2(format: string, formatProvider: IFormatProvider): string;
    }
    export interface UInt64TypeFunc extends TypeFunction {
        prototype: UInt64;
        MinValue: ulong;
        MaxValue: ulong;
        Parse(s: string): ulong;
        TryParse(s: string, result: ulong): boolean;
    }
    var UInt64: UInt64TypeFunc;

    // System.UIntPtr
    export interface UIntPtr extends ValueType {
    }
    export interface UIntPtrTypeFunc extends TypeFunction {
        prototype: UIntPtr;
        ctor: { new (): UIntPtr };
    }
    var UIntPtr: UIntPtrTypeFunc;

    // System.ValueType
    export interface ValueType extends Object {
    }
    export interface ValueTypeTypeFunc extends TypeFunction {
        prototype: ValueType;
    }
    var ValueType: ValueTypeTypeFunc;

    // void
    export interface Void extends ValueType {
    }
    export interface VoidTypeFunc extends TypeFunction {
        prototype: Void;
        ctor: { new (): void };
    }
    var Void: VoidTypeFunc;

    // System.YieldIterator<T>
    export interface YieldIterator$1<T> extends Object, Collections.Generic.IEnumerable$1<T>, Collections.IEnumerable, Collections.Generic.IEnumerator$1<T>, IDisposable, Collections.IEnumerator {
        get_Current(): T;
        GetEnumerator(): Collections.Generic.IEnumerator$1<T>;
        Dispose(): void;
        Reset(): void;
    }
    export interface YieldIterator$1TypeFunc<T> extends TypeFunction {
        (T): {
            prototype: YieldIterator$1<T>;
            ctor: { new (): YieldIterator$1<T> };
        }
    }
    var YieldIterator$1: YieldIterator$1TypeFunc<any>;
    module Collections {
        // System.Collections.Comparer
        export interface Comparer extends Object, IComparer {
            Compare(a: any, b: any): int;
        }
        export interface ComparerTypeFunc extends TypeFunction {
            prototype: Comparer;
            Default: Comparer;
            DefaultInvariant: Comparer;
            ctor: { new (culture: Globalization.CultureInfo): Comparer };
        }
        var Comparer: ComparerTypeFunc;

        // System.Collections.DictionaryEntry
        export interface DictionaryEntry extends ValueType {
            get_Key(): any;
            get_Value(): any;
        }
        export interface DictionaryEntryTypeFunc extends TypeFunction {
            prototype: DictionaryEntry;
            ctor$1: { new (key: any, value: any): DictionaryEntry };
            ctor: { new (): DictionaryEntry };
        }
        var DictionaryEntry: DictionaryEntryTypeFunc;

        // System.Collections.IComparer
        export interface IComparer {
            System$Collections$IComparer$Compare(x: any, y: any): int;
        }
        var IComparer: TypeFunction;

        // System.Collections.IDictionary
        export interface IDictionary extends ICollection, IEnumerable {
            System$Collections$IDictionary$get_Item(key: any): any;
            System$Collections$IDictionary$set_Item(key: any, value: any): void;
            System$Collections$IDictionary$get_Keys(): ICollection;
            System$Collections$IDictionary$get_Values(): ICollection;
            System$Collections$IDictionary$get_IsReadOnly(): boolean;
            System$Collections$IDictionary$get_IsFixedSize(): boolean;
            System$Collections$IDictionary$Contains(key: any): boolean;
            System$Collections$IDictionary$Add(key: any, value: any): void;
            System$Collections$IDictionary$Clear(): void;
            System$Collections$IDictionary$GetEnumerator(): IDictionaryEnumerator;
            System$Collections$IDictionary$Remove(key: any): void;
        }
        var IDictionary: TypeFunction;

        // System.Collections.IDictionaryEnumerator
        export interface IDictionaryEnumerator extends IEnumerator {
            System$Collections$IDictionaryEnumerator$get_Key(): any;
            System$Collections$IDictionaryEnumerator$get_Value(): any;
            System$Collections$IDictionaryEnumerator$get_Entry(): DictionaryEntry;
        }
        var IDictionaryEnumerator: TypeFunction;

        // System.Collections.IEqualityComparer
        export interface IEqualityComparer {
            System$Collections$IEqualityComparer$Equals(x: any, y: any): boolean;
            System$Collections$IEqualityComparer$GetHashCode(obj: any): int;
        }
        var IEqualityComparer: TypeFunction;

        // System.Collections.ICollection
        export interface ICollection extends IEnumerable {
            System$Collections$ICollection$get_Count(): int;
            System$Collections$ICollection$get_SyncRoot(): any;
            System$Collections$ICollection$get_IsSynchronized(): boolean;
            System$Collections$ICollection$CopyTo(array: Array<any>, index: int): void;
        }
        var ICollection: TypeFunction;

        // System.Collections.IEnumerable
        export interface IEnumerable {
            System$Collections$IEnumerable$GetEnumerator(): IEnumerator;
        }
        var IEnumerable: TypeFunction;

        // System.Collections.IEnumerator
        export interface IEnumerator {
            System$Collections$IEnumerator$get_Current(): any;
            System$Collections$IEnumerator$MoveNext(): boolean;
            System$Collections$IEnumerator$Reset(): void;
        }
        var IEnumerator: TypeFunction;

        // System.Collections.IList
        export interface IList extends ICollection, IEnumerable {
            System$Collections$IList$get_Item(index: int): any;
            System$Collections$IList$set_Item(index: int, value: any): void;
            System$Collections$IList$get_IsReadOnly(): boolean;
            System$Collections$IList$get_IsFixedSize(): boolean;
            System$Collections$IList$Add(value: any): int;
            System$Collections$IList$Contains(value: any): boolean;
            System$Collections$IList$Clear(): void;
            System$Collections$IList$IndexOf(value: any): int;
            System$Collections$IList$Insert(index: int, value: any): void;
            System$Collections$IList$Remove(value: any): void;
            System$Collections$IList$RemoveAt(index: int): void;
        }
        var IList: TypeFunction;

        // System.Collections.IStructuralComparable
        export interface IStructuralComparable {
            System$Collections$IStructuralComparable$CompareTo(other: any, comparer: IComparer): int;
        }
        var IStructuralComparable: TypeFunction;

        // System.Collections.IStructuralEquatable
        export interface IStructuralEquatable {
            System$Collections$IStructuralEquatable$Equals(other: any, comparer: IEqualityComparer): boolean;
            System$Collections$IStructuralEquatable$GetHashCode(comparer: IEqualityComparer): int;
        }
        var IStructuralEquatable: TypeFunction;
        module Generic {
            // System.Collections.Generic.Comparer<T>
            export interface Comparer$1<T> extends Object, IComparer, IComparer$1<T> {
                Compare(x: T, y: T): int;
            }
            export interface Comparer$1TypeFunc<T> extends TypeFunction {
                (T): {
                    prototype: Comparer$1<T>;
                    get_Default(): Comparer$1<T>;
                    Create(comparison: Comparison$1<T>): Comparer$1<T>;
                }
            }
            var Comparer$1: Comparer$1TypeFunc<any>;

            // System.Collections.Generic.Dictionary<TKey, TValue>
            export interface Dictionary$2<TKey, TValue> extends Object, IDictionary$2<TKey, TValue>, ICollection$1<KeyValuePair$2<TKey, TValue>>, IDictionary, ICollection, IReadOnlyDictionary$2<TKey, TValue>, IReadOnlyCollection$1<KeyValuePair$2<TKey, TValue>>, IEnumerable$1<KeyValuePair$2<TKey, TValue>>, IEnumerable {
                Add$1(key: TKey, value: TValue): void;
                Remove(key: TKey): boolean;
                ContainsKey(key: TKey): boolean;
                ContainsValue(value: TValue): boolean;
                Clear(): void;
                TryGetValue(key: TKey, value: TValue): boolean;
                get_Item(key: TKey): TValue;
                set_Item(key: TKey, value: TValue): void;
                get_Keys(): ICollection$1<TKey>;
                get_Values(): ICollection$1<TValue>;
                get_Count(): int;
                get_SyncRoot(): any;
                get_IsSynchronized(): boolean;
                CopyTo(array: Array<any>, index: int): void;
                GetEnumerator(): IEnumerator$1<KeyValuePair$2<TKey, TValue>>;
                get_IsReadOnly(): boolean;
                Add(item: KeyValuePair$2<TKey, TValue>): void;
                CopyTo$1(array: KeyValuePair$2<TKey, TValue>[], arrayIndex: int): void;
                get_IsFixedSize(): boolean;
            }
            export interface Dictionary$2TypeFunc<TKey, TValue> extends TypeFunction {
                (TKey, TValue): {
                    prototype: Dictionary$2<TKey, TValue>;
                    ctor: { new (): Dictionary$2<TKey, TValue> };
                    ctor$2: { new (comparer: IEqualityComparer$1<TKey>): Dictionary$2<TKey, TValue> };
                    ctor$3: { new (capacity: int): Dictionary$2<TKey, TValue> };
                    ctor$5: { new (capacity: int, comparer: IEqualityComparer$1<TKey>): Dictionary$2<TKey, TValue> };
                    ctor$1: { new (dictionary: IDictionary$2<TKey, TValue>): Dictionary$2<TKey, TValue> };
                    ctor$4: { new (dictionary: IDictionary$2<TKey, TValue>, comparer: IEqualityComparer$1<TKey>): Dictionary$2<TKey, TValue> };
                }
            }
            var Dictionary$2: Dictionary$2TypeFunc<any, any>;

            // System.Collections.Generic.EqualityComparer<T>
            export interface EqualityComparer$1<T> extends Object, IEqualityComparer, IEqualityComparer$1<T> {
                Equals$1(x: T, y: T): boolean;
                GetHashCode$1(obj: T): int;
            }
            export interface EqualityComparer$1TypeFunc<T> extends TypeFunction {
                (T): {
                    prototype: EqualityComparer$1<T>;
                    get_Default(): EqualityComparer$1<T>;
                }
            }
            var EqualityComparer$1: EqualityComparer$1TypeFunc<any>;

            // System.Collections.Generic.HashSet<T>
            export interface HashSet$1<T> extends Object, ISet$1<T>, ICollection$1<T>, IEnumerable$1<T>, IEnumerable {
                get_Count(): int;
                get_SyncRoot(): any;
                get_IsSynchronized(): boolean;
                CopyTo(array: Array<any>, index: int): void;
                GetEnumerator(): IEnumerator$1<T>;
                get_IsReadOnly(): boolean;
                Clear(): void;
                Contains(item: T): boolean;
                CopyTo$1(array: T[], arrayIndex: int): void;
                Remove(item: T): boolean;
                Add(item: T): boolean;
                UnionWith(other: IEnumerable$1<T>): void;
                IntersectWith(other: IEnumerable$1<T>): void;
                ExceptWith(other: IEnumerable$1<T>): void;
                SymmetricExceptWith(other: IEnumerable$1<T>): void;
                IsSubsetOf(other: IEnumerable$1<T>): boolean;
                IsSupersetOf(other: IEnumerable$1<T>): boolean;
                IsProperSupersetOf(other: IEnumerable$1<T>): boolean;
                IsProperSubsetOf(other: IEnumerable$1<T>): boolean;
                Overlaps(other: IEnumerable$1<T>): boolean;
                SetEquals(other: IEnumerable$1<T>): boolean;
            }
            export interface HashSet$1TypeFunc<T> extends TypeFunction {
                (T): {
                    prototype: HashSet$1<T>;
                    ctor: { new (): HashSet$1<T> };
                    ctor$1: { new (source: IEnumerable$1<T>): HashSet$1<T> };
                    ctor$2: { new (comparer: IEqualityComparer$1<T>): HashSet$1<T> };
                    ctor$3: { new (collection: IEnumerable$1<T>, comparer: IEqualityComparer$1<T>): HashSet$1<T> };
                }
            }
            var HashSet$1: HashSet$1TypeFunc<any>;

            // System.Collections.Generic.ICollection<T>
            export interface ICollection$1<T> extends IEnumerable$1<T>, IEnumerable {
                System$Collections$Generic$ICollection$1$get_Count(): int;
                System$Collections$Generic$ICollection$1$get_IsReadOnly(): boolean;
                System$Collections$Generic$ICollection$1$Add(item: T): void;
                System$Collections$Generic$ICollection$1$Clear(): void;
                System$Collections$Generic$ICollection$1$Contains(item: T): boolean;
                System$Collections$Generic$ICollection$1$CopyTo(array: T[], arrayIndex: int): void;
                System$Collections$Generic$ICollection$1$Remove(item: T): boolean;
            }
            var ICollection$1: TypeFunction;

            // System.Collections.Generic.IComparer<T>
            export interface IComparer$1<T> {
                System$Collections$Generic$IComparer$1$Compare(x: T, y: T): int;
            }
            var IComparer$1: TypeFunction;

            // System.Collections.Generic.IDictionary<TKey, TValue>
            export interface IDictionary$2<TKey, TValue> extends ICollection$1<KeyValuePair$2<TKey, TValue>>, IEnumerable$1<KeyValuePair$2<TKey, TValue>>, IEnumerable {
                System$Collections$Generic$IDictionary$2$get_Item(key: TKey): TValue;
                System$Collections$Generic$IDictionary$2$set_Item(key: TKey, value: TValue): void;
                System$Collections$Generic$IDictionary$2$get_Keys(): ICollection$1<TKey>;
                System$Collections$Generic$IDictionary$2$get_Values(): ICollection$1<TValue>;
                System$Collections$Generic$IDictionary$2$ContainsKey(key: TKey): boolean;
                System$Collections$Generic$IDictionary$2$Add(key: TKey, value: TValue): void;
                System$Collections$Generic$IDictionary$2$Remove(key: TKey): boolean;
                System$Collections$Generic$IDictionary$2$TryGetValue(key: TKey, value: TValue): boolean;
            }
            var IDictionary$2: TypeFunction;

            // System.Collections.Generic.IEnumerable<T>
            export interface IEnumerable$1<T> extends IEnumerable {
                System$Collections$Generic$IEnumerable$1$GetEnumerator(): IEnumerator$1<T>;
            }
            var IEnumerable$1: TypeFunction;

            // System.Collections.Generic.IEnumerator<T>
            export interface IEnumerator$1<T> extends IDisposable, IEnumerator {
                System$Collections$Generic$IEnumerator$1$get_Current(): T;
            }
            var IEnumerator$1: TypeFunction;

            // System.Collections.Generic.IEqualityComparer<T>
            export interface IEqualityComparer$1<T> {
                System$Collections$Generic$IEqualityComparer$1$Equals(x: T, y: T): boolean;
                System$Collections$Generic$IEqualityComparer$1$GetHashCode(obj: T): int;
            }
            var IEqualityComparer$1: TypeFunction;

            // System.Collections.Generic.IReadOnlyCollection<T>
            export interface IReadOnlyCollection$1<T> extends IEnumerable$1<T>, IEnumerable {
                System$Collections$Generic$IReadOnlyCollection$1$get_Count(): int;
            }
            var IReadOnlyCollection$1: TypeFunction;

            // System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>
            export interface IReadOnlyDictionary$2<TKey, TValue> extends IReadOnlyCollection$1<KeyValuePair$2<TKey, TValue>>, IEnumerable$1<KeyValuePair$2<TKey, TValue>>, IEnumerable {
                System$Collections$Generic$IReadOnlyDictionary$2$get_Item(key: TKey): TValue;
                System$Collections$Generic$IReadOnlyDictionary$2$get_Keys(): IEnumerable$1<TKey>;
                System$Collections$Generic$IReadOnlyDictionary$2$get_Values(): IEnumerable$1<TValue>;
                System$Collections$Generic$IReadOnlyDictionary$2$ContainsKey(key: TKey): boolean;
                System$Collections$Generic$IReadOnlyDictionary$2$TryGetValue(key: TKey, value: TValue): boolean;
            }
            var IReadOnlyDictionary$2: TypeFunction;

            // System.Collections.Generic.IReadOnlyList<T>
            export interface IReadOnlyList$1<T> extends IReadOnlyCollection$1<T>, IEnumerable$1<T>, IEnumerable {
                System$Collections$Generic$IReadOnlyList$1$get_Item(index: int): T;
            }
            var IReadOnlyList$1: TypeFunction;

            // System.Collections.Generic.KeyNotFoundException
            export interface KeyNotFoundException extends Exception {
            }
            export interface KeyNotFoundExceptionTypeFunc extends TypeFunction {
                prototype: KeyNotFoundException;
                ctor: { new (): KeyNotFoundException };
                ctor$1: { new (message: string): KeyNotFoundException };
                ctor$2: { new (message: string, innerException: Exception): KeyNotFoundException };
            }
            var KeyNotFoundException: KeyNotFoundExceptionTypeFunc;

            // System.Collections.Generic.KeyValuePair<TKey, TValue>
            export interface KeyValuePair$2<TKey, TValue> extends ValueType {
                get_Key(): TKey;
                get_Value(): TValue;
            }
            export interface KeyValuePair$2TypeFunc<TKey, TValue> extends TypeFunction {
                (TKey, TValue): {
                    prototype: KeyValuePair$2<TKey, TValue>;
                    ctor$1: { new (key: TKey, value: TValue): KeyValuePair$2<TKey, TValue> };
                    ctor: { new (): KeyValuePair$2<TKey, TValue> };
                }
            }
            var KeyValuePair$2: KeyValuePair$2TypeFunc<any, any>;

            // System.Collections.Generic.Queue<T>
            export interface Queue$1<T> extends Object, IEnumerable$1<T>, ICollection, IEnumerable {
                Clear(): void;
                Contains(item: T): boolean;
                Enqueue(item: T): void;
                Dequeue(): T;
                Peek(): T;
                get_Count(): int;
                GetEnumerator(): IEnumerator$1<T>;
                get_SyncRoot(): any;
                get_IsSynchronized(): boolean;
                CopyTo(array: Array<any>, index: int): void;
            }
            export interface Queue$1TypeFunc<T> extends TypeFunction {
                (T): {
                    prototype: Queue$1<T>;
                    ctor: { new (): Queue$1<T> };
                    ctor$2: { new (capacity: int): Queue$1<T> };
                    ctor$1: { new (collection: IEnumerable$1<T>): Queue$1<T> };
                }
            }
            var Queue$1: Queue$1TypeFunc<any>;

            // System.Collections.Generic.SortedList<TKey, TValue>
            export interface SortedList$2<TKey, TValue> extends Object, IDictionary$2<TKey, TValue>, ICollection$1<KeyValuePair$2<TKey, TValue>>, IEnumerable$1<KeyValuePair$2<TKey, TValue>>, IDictionary, ICollection, IEnumerable {
                Add(key: TKey, value: TValue): void;
                get_Capacity(): int;
                set_Capacity(value: int): void;
                get_Comparer(): IComparer$1<TKey>;
                get_Count(): int;
                get_Keys(): IList$1<TKey>;
                get_Values(): IList$1<TValue>;
                Clear(): void;
                ContainsKey(key: TKey): boolean;
                ContainsValue(value: TValue): boolean;
                GetEnumerator(): IEnumerator$1<KeyValuePair$2<TKey, TValue>>;
                get_Item(key: TKey): TValue;
                set_Item(key: TKey, value: TValue): void;
                IndexOfKey(key: TKey): int;
                IndexOfValue(value: TValue): int;
                TryGetValue(key: TKey, value: TValue): boolean;
                RemoveAt(index: int): void;
                Remove(key: TKey): boolean;
                TrimExcess(): void;
            }
            export interface SortedList$2TypeFunc<TKey, TValue> extends TypeFunction {
                (TKey, TValue): {
                    prototype: SortedList$2<TKey, TValue>;
                    ctor: { new (): SortedList$2<TKey, TValue> };
                    ctor$3: { new (capacity: int): SortedList$2<TKey, TValue> };
                    ctor$1: { new (comparer: IComparer$1<TKey>): SortedList$2<TKey, TValue> };
                    ctor$5: { new (capacity: int, comparer: IComparer$1<TKey>): SortedList$2<TKey, TValue> };
                    ctor$2: { new (dictionary: IDictionary$2<TKey, TValue>): SortedList$2<TKey, TValue> };
                    ctor$4: { new (dictionary: IDictionary$2<TKey, TValue>, comparer: IComparer$1<TKey>): SortedList$2<TKey, TValue> };
                }
            }
            var SortedList$2: SortedList$2TypeFunc<any, any>;

            // System.Collections.Generic.IList<T>
            export interface IList$1<T> extends ICollection$1<T>, IEnumerable$1<T>, IEnumerable {
                System$Collections$Generic$IList$1$get_Item(index: int): T;
                System$Collections$Generic$IList$1$set_Item(index: int, value: T): void;
                System$Collections$Generic$IList$1$IndexOf(item: T): int;
                System$Collections$Generic$IList$1$Insert(index: int, item: T): void;
                System$Collections$Generic$IList$1$RemoveAt(index: int): void;
            }
            var IList$1: TypeFunction;

            // System.Collections.Generic.ISet<T>
            export interface ISet$1<T> extends ICollection$1<T>, IEnumerable$1<T>, IEnumerable {
                System$Collections$Generic$ISet$1$UnionWith(other: IEnumerable$1<T>): void;
                System$Collections$Generic$ISet$1$IntersectWith(other: IEnumerable$1<T>): void;
                System$Collections$Generic$ISet$1$ExceptWith(other: IEnumerable$1<T>): void;
                System$Collections$Generic$ISet$1$SymmetricExceptWith(other: IEnumerable$1<T>): void;
                System$Collections$Generic$ISet$1$IsSubsetOf(other: IEnumerable$1<T>): boolean;
                System$Collections$Generic$ISet$1$IsSupersetOf(other: IEnumerable$1<T>): boolean;
                System$Collections$Generic$ISet$1$IsProperSupersetOf(other: IEnumerable$1<T>): boolean;
                System$Collections$Generic$ISet$1$IsProperSubsetOf(other: IEnumerable$1<T>): boolean;
                System$Collections$Generic$ISet$1$Overlaps(other: IEnumerable$1<T>): boolean;
                System$Collections$Generic$ISet$1$SetEquals(other: IEnumerable$1<T>): boolean;
            }
            var ISet$1: TypeFunction;

            // System.Collections.Generic.List<T>
            export interface List$1<T> extends Object, IList$1<T>, ICollection$1<T>, IReadOnlyList$1<T>, IReadOnlyCollection$1<T>, IEnumerable$1<T>, IList, ICollection, IEnumerable {
                get_Capacity(): int;
                set_Capacity(value: int): void;
                get_Count(): int;
                get_IsSynchronized(): boolean;
                get_SyncRoot(): any;
                CopyTo(array: Array<any>, index: int): void;
                get_IsReadOnly(): boolean;
                get_IsFixedSize(): boolean;
                AddRange(collection: IEnumerable$1<T>): void;
                Clear(): void;
                IndexOf$1(item: T, index: int): int;
                IndexOf$2(item: T, index: int, count: int): int;
                LastIndexOf(item: T): int;
                LastIndexOf$1(item: T, index: int): int;
                LastIndexOf$2(item: T, index: int, count: int): int;
                RemoveAt(index: int): void;
                RemoveRange(index: int, count: int): void;
                GetEnumerator(): IEnumerator$1<T>;
                Add(item: T): void;
                Contains(item: T): boolean;
                CopyTo$1(array: T[], arrayIndex: int): void;
                Remove(item: T): boolean;
                get_Item(index: int): T;
                set_Item(index: int, value: T): void;
                IndexOf(item: T): int;
                Insert(index: int, item: T): void;
                Exists(match: Predicate$1<T>): boolean;
                Find(match: Predicate$1<T>): T;
                FindAll(match: Predicate$1<T>): List$1<T>;
                FindLast(match: Predicate$1<T>): T;
                FindIndex(match: Predicate$1<T>): int;
                FindIndex$1(startIndex: int, match: Predicate$1<T>): int;
                FindIndex$2(startIndex: int, count: int, match: Predicate$1<T>): int;
                FindLastIndex(match: Predicate$1<T>): int;
                FindLastIndex$1(startIndex: int, match: Predicate$1<T>): int;
                FindLastIndex$2(startIndex: int, count: int, match: Predicate$1<T>): int;
                Reverse(): void;
                Reverse$1(index: int, count: int): void;
                Sort(): void;
                Sort$1(comparer: IComparer$1<T>): void;
                Sort$2(comparison: Comparison$1<T>): void;
                ToArray(): T[];
                BinarySearch$2(index: int, count: int, item: T, comparer: IComparer$1<T>): int;
                BinarySearch(item: T): int;
                BinarySearch$1(item: T, comparer: IComparer$1<T>): int;
                ForEach(action: Action$1<T>): void;
                GetRange(index: int, count: int): List$1<T>;
                RemoveAll(match: Predicate$1<T>): int;
                TrueForAll(match: Predicate$1<T>): boolean;
                TrimExcess(): void;
            }
            export interface List$1TypeFunc<T> extends TypeFunction {
                (T): {
                    prototype: List$1<T>;
                    ctor: { new (): List$1<T> };
                    ctor$2: { new (capacity: int): List$1<T> };
                    ctor$1: { new (collection: IEnumerable$1<T>): List$1<T> };
                }
            }
            var List$1: List$1TypeFunc<any>;

            // System.Collections.Generic.Stack<T>
            export interface Stack$1<T> extends Object, IEnumerable$1<T>, ICollection, IEnumerable {
                Clear(): void;
                Contains(item: T): boolean;
                Push(item: T): void;
                Pop(): T;
                Peek(): T;
                get_Count(): int;
                GetEnumerator(): IEnumerator$1<T>;
                get_SyncRoot(): any;
                get_IsSynchronized(): boolean;
                CopyTo(array: Array<any>, index: int): void;
            }
            export interface Stack$1TypeFunc<T> extends TypeFunction {
                (T): {
                    prototype: Stack$1<T>;
                    ctor: { new (): Stack$1<T> };
                    ctor$2: { new (capacity: int): Stack$1<T> };
                    ctor$1: { new (collection: IEnumerable$1<T>): Stack$1<T> };
                }
            }
            var Stack$1: Stack$1TypeFunc<any>;
        }
        module ObjectModel {
            // System.Collections.ObjectModel.ReadOnlyCollection<T>
            export interface ReadOnlyCollection$1<T> extends Object, Generic.IList$1<T>, Generic.ICollection$1<T>, IList, ICollection, Generic.IReadOnlyList$1<T>, Generic.IReadOnlyCollection$1<T>, Generic.IEnumerable$1<T>, IEnumerable {
                get_Count(): int;
                get_Item(index: int): T;
                Contains(value: T): boolean;
                CopyTo(array: T[], index: int): void;
                GetEnumerator(): Generic.IEnumerator$1<T>;
                IndexOf(value: T): int;
            }
            export interface ReadOnlyCollection$1TypeFunc<T> extends TypeFunction {
                (T): {
                    prototype: ReadOnlyCollection$1<T>;
                    ctor: { new (list: Generic.IList$1<T>): ReadOnlyCollection$1<T> };
                }
            }
            var ReadOnlyCollection$1: ReadOnlyCollection$1TypeFunc<any>;
        }
    }
    module Diagnostics {
        // System.Diagnostics.Debug
        export interface Debug extends Object {
        }
        export interface DebugTypeFunc extends TypeFunction {
            prototype: Debug;
            ctor: { new (): Debug };
            Assert(condition: boolean): void;
        }
        var Debug: DebugTypeFunc;

        // System.Diagnostics.Debugger
        export interface DebuggerTypeFunc extends TypeFunction {
            DefaultCategory: string;
            Break(): void;
            Launch(): boolean;
            get_IsAttached(): boolean;
            Log(level: int, category: string, message: string): void;
            IsLogging(): boolean;
        }
        var Debugger: DebuggerTypeFunc;
    }
    module Drawing {
        // System.Drawing.Bitmap
        export interface Bitmap extends Object {
        }
        export interface BitmapTypeFunc extends TypeFunction {
            prototype: Bitmap;
            ctor: { new (image: HTMLImageElement): Bitmap };
        }
        var Bitmap: BitmapTypeFunc;
    }
    module Globalization {
        // System.Globalization.CompareInfo
        export interface CompareInfo extends Object {
            Compare(string1: string, string2: string): int;
            Compare$1(string1: string, string2: string, options: CompareOptions): int;
            Compare$4(string1: string, offset1: int, length1: int, string2: string, offset2: int, length2: int): int;
            Compare$3(string1: string, offset1: int, string2: string, offset2: int, options: CompareOptions): int;
            Compare$2(string1: string, offset1: int, string2: string, offset2: int): int;
            Compare$5(string1: string, offset1: int, length1: int, string2: string, offset2: int, length2: int, options: CompareOptions): int;
        }
        export interface CompareInfoTypeFunc extends TypeFunction {
            prototype: CompareInfo;
            ctor: { new (): CompareInfo };
        }
        var CompareInfo: CompareInfoTypeFunc;

        // System.Globalization.CompareOptions
        export enum CompareOptions {
            None = 0,
            IgnoreCase = 1,
            IgnoreNonSpace = 2,
            IgnoreSymbols = 4,
            IgnoreKanaType = 8,
            IgnoreWidth = 16,
            OrdinalIgnoreCase = 268435456,
            StringSort = 536870912,
            Ordinal = 1073741824
        }

        // System.Globalization.CultureInfo
        export interface CultureInfo extends Object, IFormatProvider {
            get_Name(): string;
            get_CompareInfo(): CompareInfo;
            GetFormat(formatType: Type): any;
        }
        export interface CultureInfoTypeFunc extends TypeFunction {
            prototype: CultureInfo;
            CurrentCulture: CultureInfo;
            InvariantCulture: CultureInfo;
            ctor: { new (): CultureInfo };
        }
        var CultureInfo: CultureInfoTypeFunc;
    }
    module IO {
        // System.IO.IOException
        export interface IOException extends SystemException {
        }
        export interface IOExceptionTypeFunc extends TypeFunction {
            prototype: IOException;
            ctor: { new (): IOException };
            ctor$1: { new (message: string): IOException };
            ctor$3: { new (message: string, hresult: int): IOException };
            ctor$2: { new (message: string, innerException: Exception): IOException };
        }
        var IOException: IOExceptionTypeFunc;

        // System.IO.MemoryStream
        export interface MemoryStream extends Stream, IDisposable {
            GetBuffer(): byte[];
            get_Capacity(): int;
            set_Capacity(value: int): void;
            ToArray(): byte[];
            WriteTo(stream: Stream): void;
        }
        export interface MemoryStreamTypeFunc extends TypeFunction {
            prototype: MemoryStream;
            ctor: { new (): MemoryStream };
            ctor$2: { new (capacity: int): MemoryStream };
            ctor$1: { new (buffer: byte[]): MemoryStream };
            ctor$3: { new (buffer: byte[], writable: boolean): MemoryStream };
            ctor$4: { new (buffer: byte[], index: int, count: int): MemoryStream };
            ctor$5: { new (buffer: byte[], index: int, count: int, writable: boolean): MemoryStream };
            ctor$6: { new (buffer: byte[], index: int, count: int, writable: boolean, publiclyVisible: boolean): MemoryStream };
        }
        var MemoryStream: MemoryStreamTypeFunc;

        // System.IO.Path
        export interface PathTypeFunc extends TypeFunction {
            DirectorySeparatorChar: char;
            AltDirectorySeparatorChar: char;
            VolumeSeparatorChar: char;
            PathSeparator: char;
            InvalidPathChars: char[];
            ChangeExtension(path: string, extension: string): string;
            GetDirectoryName(path: string): string;
            GetInvalidPathChars(): char[];
            GetInvalidFileNameChars(): char[];
            GetExtension(path: string): string;
            GetFullPath(path: string): string;
            GetFileName(path: string): string;
            GetFileNameWithoutExtension(path: string): string;
            GetPathRoot(path: string): string;
            HasExtension(path: string): boolean;
            IsPathRooted(path: string): boolean;
            Combine$1(path1: string, path2: string): string;
            Combine$2(path1: string, path2: string, path3: string): string;
            Combine$3(path1: string, path2: string, path3: string, path4: string): string;
            Combine(paths: string[]): string;
        }
        var Path: PathTypeFunc;

        // System.IO.PathTooLongException
        export interface PathTooLongException extends Exception {
        }
        export interface PathTooLongExceptionTypeFunc extends TypeFunction {
            prototype: PathTooLongException;
            ctor: { new (message: string): PathTooLongException };
        }
        var PathTooLongException: PathTooLongExceptionTypeFunc;

        // System.IO.SeekOrigin
        export enum SeekOrigin {
            Begin = 0,
            Current = 1,
            End = 2
        }

        // System.IO.Stream
        export interface Stream extends Object, IDisposable {
            get_CanRead(): boolean;
            get_CanSeek(): boolean;
            get_CanTimeout(): boolean;
            get_CanWrite(): boolean;
            get_Length(): long;
            get_Position(): long;
            set_Position(value: long): void;
            get_ReadTimeout(): int;
            set_ReadTimeout(value: int): void;
            get_WriteTimeout(): int;
            set_WriteTimeout(value: int): void;
            CopyTo(destination: Stream): void;
            CopyTo$1(destination: Stream, bufferSize: int): void;
            Close(): void;
            Dispose(): void;
            Flush(): void;
            Seek(offset: long, origin: SeekOrigin): long;
            SetLength(value: long): void;
            Read(buffer: byte[], offset: int, count: int): int;
            ReadByte(): int;
            Write(buffer: byte[], offset: int, count: int): void;
            WriteByte(value: byte): void;
        }
        export interface StreamTypeFunc extends TypeFunction {
            prototype: Stream;
            Null: Stream;
        }
        var Stream: StreamTypeFunc;
    }
    module Linq {
        // System.Linq.Enumerable
        export interface EnumerableTypeFunc extends TypeFunction {
            Aggregate<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, func: Func$3<TSource, TSource, TSource>): TSource;
            Aggregate$1<TSource, TAccumulate>(TSource, TAccumulate, source: Collections.Generic.IEnumerable$1<TSource>, seed: TAccumulate, func: Func$3<TAccumulate, TSource, TAccumulate>): TAccumulate;
            Aggregate$2<TSource, TAccumulate, TResult>(TSource, TAccumulate, TResult, source: Collections.Generic.IEnumerable$1<TSource>, seed: TAccumulate, func: Func$3<TAccumulate, TSource, TAccumulate>, resultSelector: Func$2<TAccumulate, TResult>): TResult;
            All<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): boolean;
            Where<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): Collections.Generic.IEnumerable$1<TSource>;
            Where$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$3<TSource, int, boolean>): Collections.Generic.IEnumerable$1<TSource>;
            First$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): TSource;
            FirstOrDefault$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): TSource;
            First<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): TSource;
            FirstOrDefault<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): TSource;
            FirstOrDefault$2<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, defaultValue: Func$1<TSource>): TSource;
            Last$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): TSource;
            LastOrDefault$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): TSource;
            Last<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): TSource;
            LastOrDefault<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): TSource;
            LastOrDefault$2<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, defaultValue: Func$1<TSource>): TSource;
            Single$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): TSource;
            SingleOrDefault$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): TSource;
            Single<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): TSource;
            SingleOrDefault<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): TSource;
            SingleOrDefault$2<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, defaultValue: Func$1<TSource>): TSource;
            ToArray<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): TSource[];
            ToList<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): Collections.Generic.List$1<TSource>;
            Select<TSource, TResult>(TSource, TResult, source: Collections.Generic.IEnumerable$1<TSource>, selector: Func$2<TSource, TResult>): Collections.Generic.IEnumerable$1<TResult>;
            Select$1<TSource, TResult>(TSource, TResult, source: Collections.Generic.IEnumerable$1<TSource>, selector: Func$3<TSource, int, TResult>): Collections.Generic.IEnumerable$1<TResult>;
            SelectMany<TSource, TResult>(TSource, TResult, source: Collections.Generic.IEnumerable$1<TSource>, selector: Func$2<TSource, Collections.Generic.IEnumerable$1<TResult>>): Collections.Generic.IEnumerable$1<TResult>;
            SelectMany$1<TSource, TResult>(TSource, TResult, source: Collections.Generic.IEnumerable$1<TSource>, selector: Func$3<TSource, int, Collections.Generic.IEnumerable$1<TResult>>): Collections.Generic.IEnumerable$1<TResult>;
            SelectMany$3<TSource, TCollection, TResult>(TSource, TCollection, TResult, source: Collections.Generic.IEnumerable$1<TSource>, collectionSelector: Func$3<TSource, int, Collections.Generic.IEnumerable$1<TCollection>>, resultSelector: Func$3<TSource, TCollection, TResult>): Collections.Generic.IEnumerable$1<TResult>;
            SelectMany$2<TSource, TCollection, TResult>(TSource, TCollection, TResult, source: Collections.Generic.IEnumerable$1<TSource>, collectionSelector: Func$2<TSource, Collections.Generic.IEnumerable$1<TCollection>>, resultSelector: Func$3<TSource, TCollection, TResult>): Collections.Generic.IEnumerable$1<TResult>;
            Take<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, count: int): Collections.Generic.IEnumerable$1<TSource>;
            TakeWhile<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): Collections.Generic.IEnumerable$1<TSource>;
            TakeWhile$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$3<TSource, int, boolean>): Collections.Generic.IEnumerable$1<TSource>;
            Skip<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, count: int): Collections.Generic.IEnumerable$1<TSource>;
            SkipWhile<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): Collections.Generic.IEnumerable$1<TSource>;
            SkipWhile$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$3<TSource, int, boolean>): Collections.Generic.IEnumerable$1<TSource>;
            Join<TOuter, TInner, TKey, TResult>(TOuter, TInner, TKey, TResult, outer: Collections.Generic.IEnumerable$1<TOuter>, inner: Collections.Generic.IEnumerable$1<TInner>, outerKeySelector: Func$2<TOuter, TKey>, innerKeySelector: Func$2<TInner, TKey>, resultSelector: Func$3<TOuter, TInner, TResult>): Collections.Generic.IEnumerable$1<TResult>;
            Any<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): boolean;
            Any$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): boolean;
            Max<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): TSource;
            Min<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): TSource;
            Concat<T>(T, source: Collections.Generic.IEnumerable$1<T>, other: Collections.Generic.IEnumerable$1<T>): Collections.Generic.IEnumerable$1<T>;
            Sum(source: Collections.Generic.IEnumerable$1<Nullable$1<double>>): Nullable$1<double>;
            Sum$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, selector: Func$2<TSource, Nullable$1<double>>): Nullable$1<double>;
            Repeat<TResult>(TResult, element: TResult, count: int): Collections.Generic.IEnumerable$1<TResult>;
            Reverse<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): Collections.Generic.IEnumerable$1<TSource>;
            ToDictionary<TSource, TKey>(TSource, TKey, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>): Collections.Generic.Dictionary$2<TKey, TSource>;
            ToDictionary$1<TSource, TKey, TValue>(TSource, TKey, TValue, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, valueSelector: Func$2<TSource, TValue>): Collections.Generic.Dictionary$2<TKey, TValue>;
            SequenceEqual<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, other: Collections.Generic.IEnumerable$1<TSource>): boolean;
            SequenceEqual$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, other: Collections.Generic.IEnumerable$1<TSource>, comparer: Collections.Generic.IEqualityComparer$1<TSource>): boolean;
            Cast<TResult>(TResult, source: Collections.IEnumerable): Collections.Generic.IEnumerable$1<TResult>;
            OrderBy<TSource, TKey>(TSource, TKey, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>): IOrderedEnumerable$1<TSource>;
            OrderBy$1<TSource, TKey>(TSource, TKey, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, comparer: Collections.Generic.IComparer$1<TKey>): IOrderedEnumerable$1<TSource>;
            OrderByDescending<TSource, TKey>(TSource, TKey, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>): IOrderedEnumerable$1<TSource>;
            OrderByDescending$1<TSource, TKey>(TSource, TKey, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, comparer: Collections.Generic.IComparer$1<TKey>): IOrderedEnumerable$1<TSource>;
            ThenBy<TSource, TKey>(TSource, TKey, source: IOrderedEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>): IOrderedEnumerable$1<TSource>;
            ThenBy$1<TSource, TKey>(TSource, TKey, source: IOrderedEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, comparer: Collections.Generic.IComparer$1<TKey>): IOrderedEnumerable$1<TSource>;
            ThenByDescending<TSource, TKey>(TSource, TKey, source: IOrderedEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>): IOrderedEnumerable$1<TSource>;
            ThenByDescending$1<TSource, TKey>(TSource, TKey, source: IOrderedEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, comparer: Collections.Generic.IComparer$1<TKey>): IOrderedEnumerable$1<TSource>;
            OfType<TResult>(TResult, source: Collections.IEnumerable): Collections.Generic.IEnumerable$1<TResult>;
            Empty<TResult>(TResult): Collections.Generic.IEnumerable$1<TResult>;
            DefaultIfEmpty<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): Collections.Generic.IEnumerable$1<TSource>;
            DefaultIfEmpty$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, defaultValue: TSource): Collections.Generic.IEnumerable$1<TSource>;
            GroupBy<TSource, TKey>(TSource, TKey, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>): Collections.Generic.IEnumerable$1<IGrouping$2<TKey, TSource>>;
            GroupBy$1<TSource, TKey>(TSource, TKey, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, comparer: Collections.Generic.IEqualityComparer$1<TKey>): Collections.Generic.IEnumerable$1<IGrouping$2<TKey, TSource>>;
            GroupBy$3<TSource, TKey, TElement>(TSource, TKey, TElement, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, elementSelector: Func$2<TSource, TElement>): Collections.Generic.IEnumerable$1<IGrouping$2<TKey, TElement>>;
            GroupBy$5<TSource, TKey, TElement>(TSource, TKey, TElement, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, elementSelector: Func$2<TSource, TElement>, comparer: Collections.Generic.IEqualityComparer$1<TKey>): Collections.Generic.IEnumerable$1<IGrouping$2<TKey, TElement>>;
            GroupBy$2<TSource, TKey, TResult>(TSource, TKey, TResult, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, resultSelector: Func$3<TKey, Collections.Generic.IEnumerable$1<TSource>, TResult>): Collections.Generic.IEnumerable$1<TResult>;
            GroupBy$6<TSource, TKey, TElement, TResult>(TSource, TKey, TElement, TResult, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, elementSelector: Func$2<TSource, TElement>, resultSelector: Func$3<TKey, Collections.Generic.IEnumerable$1<TElement>, TResult>): Collections.Generic.IEnumerable$1<TResult>;
            GroupBy$4<TSource, TKey, TResult>(TSource, TKey, TResult, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, resultSelector: Func$3<TKey, Collections.Generic.IEnumerable$1<TSource>, TResult>, comparer: Collections.Generic.IEqualityComparer$1<TKey>): Collections.Generic.IEnumerable$1<TResult>;
            GroupBy$7<TSource, TKey, TElement, TResult>(TSource, TKey, TElement, TResult, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, elementSelector: Func$2<TSource, TElement>, resultSelector: Func$3<TKey, Collections.Generic.IEnumerable$1<TElement>, TResult>, comparer: Collections.Generic.IEqualityComparer$1<TKey>): Collections.Generic.IEnumerable$1<TResult>;
            ToLookup<TSource, TKey>(TSource, TKey, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>): ILookup$2<TKey, TSource>;
            ToLookup$1<TSource, TKey>(TSource, TKey, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, comparer: Collections.Generic.IEqualityComparer$1<TKey>): ILookup$2<TKey, TSource>;
            ToLookup$2<TSource, TKey, TElement>(TSource, TKey, TElement, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, elementSelector: Func$2<TSource, TElement>): ILookup$2<TKey, TElement>;
            ToLookup$3<TSource, TKey, TElement>(TSource, TKey, TElement, source: Collections.Generic.IEnumerable$1<TSource>, keySelector: Func$2<TSource, TKey>, elementSelector: Func$2<TSource, TElement>, comparer: Collections.Generic.IEqualityComparer$1<TKey>): ILookup$2<TKey, TElement>;
            Distinct<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): Collections.Generic.IEnumerable$1<TSource>;
            Distinct$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, comparer: Collections.Generic.IEqualityComparer$1<TSource>): Collections.Generic.IEnumerable$1<TSource>;
            ElementAt<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, index: int): TSource;
            ElementAtOrDefault<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, index: int): TSource;
            Range(start: int, count: int): Collections.Generic.IEnumerable$1<int>;
            Zip<TFirst, TSecond, TResult>(TFirst, TSecond, TResult, first: Collections.Generic.IEnumerable$1<TFirst>, second: Collections.Generic.IEnumerable$1<TSecond>, resultSelector: Func$3<TFirst, TSecond, TResult>): Collections.Generic.IEnumerable$1<TResult>;
            Union<TSource>(TSource, first: Collections.Generic.IEnumerable$1<TSource>, second: Collections.Generic.IEnumerable$1<TSource>): Collections.Generic.IEnumerable$1<TSource>;
            Union$1<TSource>(TSource, first: Collections.Generic.IEnumerable$1<TSource>, second: Collections.Generic.IEnumerable$1<TSource>, comparer: Collections.Generic.IEqualityComparer$1<TSource>): Collections.Generic.IEnumerable$1<TSource>;
            Intersect<TSource>(TSource, first: Collections.Generic.IEnumerable$1<TSource>, second: Collections.Generic.IEnumerable$1<TSource>): Collections.Generic.IEnumerable$1<TSource>;
            Intersect$1<TSource>(TSource, first: Collections.Generic.IEnumerable$1<TSource>, second: Collections.Generic.IEnumerable$1<TSource>, comparer: Collections.Generic.IEqualityComparer$1<TSource>): Collections.Generic.IEnumerable$1<TSource>;
            Average$6<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, selector: Func$2<TSource, double>): double;
            Average$1(source: Collections.Generic.IEnumerable$1<Nullable$1<double>>): Nullable$1<double>;
            Average(source: Collections.Generic.IEnumerable$1<double>): double;
            Average$7<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, selector: Func$2<TSource, long>): double;
            Average$5(source: Collections.Generic.IEnumerable$1<Nullable$1<long>>): Nullable$1<double>;
            Average$4(source: Collections.Generic.IEnumerable$1<long>): double;
            Average$3(source: Collections.Generic.IEnumerable$1<Nullable$1<int>>): Nullable$1<double>;
            Average$2(source: Collections.Generic.IEnumerable$1<int>): double;
            Count<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): int;
            Count$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): int;
            LongCount<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>): long;
            LongCount$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, predicate: Func$2<TSource, boolean>): long;
            Contains<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, value: TSource): boolean;
            Contains$1<TSource>(TSource, source: Collections.Generic.IEnumerable$1<TSource>, value: TSource, comparer: Collections.Generic.IEqualityComparer$1<TSource>): boolean;
            Except<TSource>(TSource, first: Collections.Generic.IEnumerable$1<TSource>, second: Collections.Generic.IEnumerable$1<TSource>): Collections.Generic.IEnumerable$1<TSource>;
            Except$1<TSource>(TSource, first: Collections.Generic.IEnumerable$1<TSource>, second: Collections.Generic.IEnumerable$1<TSource>, comparer: Collections.Generic.IEqualityComparer$1<TSource>): Collections.Generic.IEnumerable$1<TSource>;
        }
        var Enumerable: EnumerableTypeFunc;

        // System.Linq.IGrouping<TKey, TElement>
        export interface IGrouping$2<TKey, TElement> extends Collections.Generic.IEnumerable$1<TElement>, Collections.IEnumerable {
            System$Linq$IGrouping$2$get_Key(): TKey;
        }
        var IGrouping$2: TypeFunction;

        // System.Linq.ILookup<TKey, TElement>
        export interface ILookup$2<TKey, TElement> extends Collections.Generic.IEnumerable$1<IGrouping$2<TKey, TElement>>, Collections.IEnumerable {
            System$Linq$ILookup$2$get_Count(): int;
            System$Linq$ILookup$2$get_Item(key: TKey): Collections.Generic.IEnumerable$1<TElement>;
            System$Linq$ILookup$2$Contains(key: TKey): boolean;
        }
        var ILookup$2: TypeFunction;

        // System.Linq.IOrderedEnumerable<TElement>
        export interface IOrderedEnumerable$1<TElement> extends Collections.Generic.IEnumerable$1<TElement>, Collections.IEnumerable {
            System$Linq$IOrderedEnumerable$1$CreateOrderedEnumerable<TKey>(TKey, keySelector: Func$2<TElement, TKey>, comparer: Collections.Generic.IComparer$1<TKey>, descending: boolean): IOrderedEnumerable$1<TElement>;
        }
        var IOrderedEnumerable$1: TypeFunction;

        // System.Linq.Lookup<TKey, TElement>
        export interface Lookup$2<TKey, TElement> extends Object, ILookup$2<TKey, TElement>, Collections.Generic.IEnumerable$1<IGrouping$2<TKey, TElement>>, Collections.IEnumerable {
            GetEnumerator(): Collections.Generic.IEnumerator$1<IGrouping$2<TKey, TElement>>;
            get_Count(): int;
            get_Item(key: TKey): Collections.Generic.IEnumerable$1<TElement>;
            Contains(key: TKey): boolean;
        }
        export interface Lookup$2TypeFunc<TKey, TElement> extends TypeFunction {
            (TKey, TElement): {
                prototype: Lookup$2<TKey, TElement>;
                ctor: { new (elements: Collections.Generic.IEnumerable$1<IGrouping$2<TKey, TElement>>): Lookup$2<TKey, TElement> };
            }
        }
        var Lookup$2: Lookup$2TypeFunc<any, any>;

        // System.Linq.OrderedEnumerable<TElement>
        export interface OrderedEnumerable$1<TElement> extends Object, IOrderedEnumerable$1<TElement>, Collections.Generic.IEnumerable$1<TElement>, Collections.IEnumerable {
            GetEnumerator(): Collections.Generic.IEnumerator$1<TElement>;
            CreateOrderedEnumerable<TKey>(TKey, keySelector: Func$2<TElement, TKey>, comparer: Collections.Generic.IComparer$1<TKey>, descending: boolean): IOrderedEnumerable$1<TElement>;
        }
        export interface OrderedEnumerable$1TypeFunc<TElement> extends TypeFunction {
            (TElement): {
                prototype: OrderedEnumerable$1<TElement>;
            }
        }
        var OrderedEnumerable$1: OrderedEnumerable$1TypeFunc<any>;
        module Expressions {
            // System.Linq.Expressions.BinaryExpression
            export interface BinaryExpression extends Expression {
                get_Left(): Expression;
                get_Right(): Expression;
                get_Method(): Reflection.MethodInfo;
                get_Conversion(): LambdaExpression;
                get_IsLifted(): boolean;
                Update(left: Expression, conversion: LambdaExpression, right: Expression): BinaryExpression;
                get_IsLiftedToNull(): boolean;
            }
            export interface BinaryExpressionTypeFunc extends TypeFunction {
                prototype: BinaryExpression;
                ctor: { new (left: Expression, right: Expression, nodeType: ExpressionType): BinaryExpression };
                ctor$1: { new (left: Expression, right: Expression, nodeType: ExpressionType, liftToNull: boolean, method: Reflection.MethodInfo): BinaryExpression };
            }
            var BinaryExpression: BinaryExpressionTypeFunc;

            // System.Linq.Expressions.ConditionalExpression
            export interface ConditionalExpression extends Expression {
                get_Test(): Expression;
                get_IfTrue(): Expression;
                get_IfFalse(): Expression;
                Update(test: Expression, ifTrue: Expression, ifFalse: Expression): Expression;
            }
            export interface ConditionalExpressionTypeFunc extends TypeFunction {
                prototype: ConditionalExpression;
                ctor: { new (test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression };
                ctor$1: { new (test: Expression, ifTrue: Expression, ifFalse: Expression, type: Type): ConditionalExpression };
            }
            var ConditionalExpression: ConditionalExpressionTypeFunc;

            // System.Linq.Expressions.ConstantExpression
            export interface ConstantExpression extends Expression {
                get_Value(): any;
            }
            export interface ConstantExpressionTypeFunc extends TypeFunction {
                prototype: ConstantExpression;
                ctor: { new (value: any): ConstantExpression };
                ctor$1: { new (value: any, type: Type): ConstantExpression };
            }
            var ConstantExpression: ConstantExpressionTypeFunc;

            // System.Linq.Expressions.DefaultExpression
            export interface DefaultExpression extends Expression {
            }
            export interface DefaultExpressionTypeFunc extends TypeFunction {
                prototype: DefaultExpression;
                ctor: { new (type: Type): DefaultExpression };
            }
            var DefaultExpression: DefaultExpressionTypeFunc;

            // System.Linq.Expressions.ElementInit
            export interface ElementInit extends Object {
                get_AddMethod(): Reflection.MethodInfo;
                get_Arguments(): Collections.Generic.List$1<Expression>;
                Update(args: Collections.Generic.List$1<Expression>): ElementInit;
            }
            export interface ElementInitTypeFunc extends TypeFunction {
                prototype: ElementInit;
                ctor: { new (addMethod: Reflection.MethodInfo, args: Collections.Generic.List$1<Expression>): ElementInit };
            }
            var ElementInit: ElementInitTypeFunc;

            // System.Linq.Expressions.Expression
            export interface Expression extends Object {
                get_NodeType(): ExpressionType;
                Accept(visitor: ExpressionVisitor): Expression;
                get_Type(): Type;
            }
            export interface ExpressionTypeFunc extends TypeFunction {
                prototype: Expression;
                Lambda$2<TDelegate>(TDelegate, body: Expression, parameters: ParameterExpression[]): Expression$1<TDelegate>;
                Lambda$3<TDelegate>(TDelegate, body: Expression, name: string, tailCall: boolean, parameters: ParameterExpression[]): Expression$1<TDelegate>;
                Lambda(delegateType: Type, body: Expression, parameters: ParameterExpression[]): LambdaExpression;
                Lambda$1(delegateType: Type, body: Expression, name: string, tailCall: boolean, parameters: Collections.Generic.IEnumerable$1<ParameterExpression>): LambdaExpression;
                Property$6(instance: Expression, propertyName: string, args: Expression[]): IndexExpression;
                Property$4(instance: Expression, indexer: Reflection.PropertyInfo, args: Expression[]): IndexExpression;
                Property$3(instance: Expression, indexer: Reflection.PropertyInfo, args: Collections.Generic.IEnumerable$1<Expression>): IndexExpression;
                Property$2(expression: Expression, propertyName: string): MemberExpression;
                Property$5(expression: Expression, type: Type, propertyName: string): MemberExpression;
                Property$1(expression: Expression, property: Reflection.PropertyInfo): MemberExpression;
                Property(expression: Expression, propertyAccessor: Reflection.MethodInfo): MemberExpression;
                PropertyOrField(expression: Expression, propertyOrFieldName: string): MemberExpression;
                Parameter(type: Type): ParameterExpression;
                Variable(type: Type): ParameterExpression;
                Variable$1(type: Type, name: string): ParameterExpression;
                Parameter$1(type: Type, name: string): ParameterExpression;
                MakeMemberAccess(target: Expression, member: Reflection.MemberInfo): MemberExpression;
                Call$1(target: Expression, method: Reflection.MethodInfo, args: Expression[]): MethodCallExpression;
                Call(method: Reflection.MethodInfo, args: Expression[]): MethodCallExpression;
                Constant(value: any): ConstantExpression;
                Constant$1(value: any, type: Type): ConstantExpression;
                MakeBinary$1(nodeType: ExpressionType, left: Expression, right: Expression, liftToNull: boolean, method: Reflection.MethodInfo): BinaryExpression;
                MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression): BinaryExpression;
                MakeUnary(unaryType: ExpressionType, operand: Expression, type: Type): UnaryExpression;
                MakeUnary$1(unaryType: ExpressionType, operand: Expression, type: Type, method: Reflection.MethodInfo): UnaryExpression;
                New$1(type: Type): NewExpression;
                New(constructor: Reflection.ConstructorInfo): NewExpression;
                New$3(constructor: Reflection.ConstructorInfo, args: Expression[]): NewExpression;
                New$2(constructor: Reflection.ConstructorInfo, args: Collections.Generic.IEnumerable$1<Expression>): NewExpression;
                Bind(member: Reflection.MemberInfo, expression: Expression): MemberAssignment;
                Bind$1(propertyAccessor: Reflection.MethodInfo, expression: Expression): MemberAssignment;
                MemberInit$1(newExpression: NewExpression, bindings: MemberBinding[]): MemberInitExpression;
                MemberInit(newExpression: NewExpression, bindings: Collections.Generic.IEnumerable$1<MemberBinding>): MemberInitExpression;
                ListInit$3(newExpression: NewExpression, initializers: Expression[]): ListInitExpression;
                ListInit$1(newExpression: NewExpression, initializers: Collections.Generic.IEnumerable$1<Expression>): ListInitExpression;
                ListInit$5(newExpression: NewExpression, addMethod: Reflection.MethodInfo, initializers: Expression[]): ListInitExpression;
                ListInit$4(newExpression: NewExpression, addMethod: Reflection.MethodInfo, initializers: Collections.Generic.IEnumerable$1<Expression>): ListInitExpression;
                ListInit$2(newExpression: NewExpression, initializers: ElementInit[]): ListInitExpression;
                ListInit(newExpression: NewExpression, initializers: Collections.Generic.IEnumerable$1<ElementInit>): ListInitExpression;
                ElementInit$1(addMethod: Reflection.MethodInfo, args: Expression[]): ElementInit;
                ElementInit(addMethod: Reflection.MethodInfo, args: Collections.Generic.IEnumerable$1<Expression>): ElementInit;
                NewArrayInit$1(type: Type, initializers: Expression[]): NewArrayExpression;
                NewArrayInit(type: Type, initializers: Collections.Generic.IEnumerable$1<Expression>): NewArrayExpression;
                NewArrayBounds$1(type: Type, bounds: Expression[]): NewArrayExpression;
                NewArrayBounds(type: Type, bounds: Collections.Generic.IEnumerable$1<Expression>): NewArrayExpression;
                TypeAs(expression: Expression, type: Type): UnaryExpression;
                TypeIs(expression: Expression, type: Type): TypeBinaryExpression;
                Default(type: Type): DefaultExpression;
                MakeIndex(target: Expression, indexer: Reflection.PropertyInfo, args: Collections.Generic.IEnumerable$1<Expression>): IndexExpression;
                ArrayIndex$2(array: Expression, indexes: Expression[]): MethodCallExpression;
                ArrayIndex(array: Expression, indexes: Collections.Generic.IEnumerable$1<Expression>): MethodCallExpression;
                ArrayIndex$1(array: Expression, index: Expression): BinaryExpression;
                Condition(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
                Condition$1(test: Expression, ifTrue: Expression, ifFalse: Expression, type: Type): ConditionalExpression;
                Invoke$1(expression: Expression, args: Expression[]): InvocationExpression;
                Invoke(expression: Expression, args: Collections.Generic.IEnumerable$1<Expression>): InvocationExpression;
                Field(expression: Expression, field: Reflection.FieldInfo): MemberExpression;
                Field$1(expression: Expression, fieldName: string): MemberExpression;
                Field$2(expression: Expression, type: Type, fieldName: string): MemberExpression;
                Convert(expression: Expression, type: Type): UnaryExpression;
                Convert$1(expression: Expression, type: Type, method: Reflection.MethodInfo): UnaryExpression;
                Add(left: Expression, right: Expression): BinaryExpression;
                Add$1(left: Expression, right: Expression, method: Reflection.MethodInfo): BinaryExpression;
            }
            var Expression: ExpressionTypeFunc;

            // System.Linq.Expressions.Expression<TDelegate>
            export interface Expression$1<TDelegate> extends LambdaExpression {
                Compile$1(): TDelegate;
            }
            export interface Expression$1TypeFunc<TDelegate> extends TypeFunction {
                (TDelegate): {
                    prototype: Expression$1<TDelegate>;
                }
            }
            var Expression$1: Expression$1TypeFunc<any>;

            // System.Linq.Expressions.ExpressionType
            export enum ExpressionType {
                Add = 0,
                AddChecked = 1,
                And = 2,
                AndAlso = 3,
                ArrayLength = 4,
                ArrayIndex = 5,
                Call = 6,
                Coalesce = 7,
                Conditional = 8,
                Constant = 9,
                Convert = 10,
                ConvertChecked = 11,
                Divide = 12,
                Equal = 13,
                ExclusiveOr = 14,
                GreaterThan = 15,
                GreaterThanOrEqual = 16,
                Invoke = 17,
                Lambda = 18,
                LeftShift = 19,
                LessThan = 20,
                LessThanOrEqual = 21,
                ListInit = 22,
                MemberAccess = 23,
                MemberInit = 24,
                Modulo = 25,
                Multiply = 26,
                MultiplyChecked = 27,
                Negate = 28,
                UnaryPlus = 29,
                NegateChecked = 30,
                New = 31,
                NewArrayInit = 32,
                NewArrayBounds = 33,
                Not = 34,
                NotEqual = 35,
                Or = 36,
                OrElse = 37,
                Parameter = 38,
                Power = 39,
                Quote = 40,
                RightShift = 41,
                Subtract = 42,
                SubtractChecked = 43,
                TypeAs = 44,
                TypeIs = 45,
                Assign = 46,
                Block = 47,
                DebugInfo = 48,
                Decrement = 49,
                Dynamic = 50,
                Default = 51,
                Extension = 52,
                Goto = 53,
                Increment = 54,
                Index = 55,
                Label = 56,
                RuntimeVariables = 57,
                Loop = 58,
                Switch = 59,
                Throw = 60,
                Try = 61,
                Unbox = 62,
                AddAssign = 63,
                AndAssign = 64,
                DivideAssign = 65,
                ExclusiveOrAssign = 66,
                LeftShiftAssign = 67,
                ModuloAssign = 68,
                MultiplyAssign = 69,
                OrAssign = 70,
                PowerAssign = 71,
                RightShiftAssign = 72,
                SubtractAssign = 73,
                AddAssignChecked = 74,
                MultiplyAssignChecked = 75,
                SubtractAssignChecked = 76,
                PreIncrementAssign = 77,
                PreDecrementAssign = 78,
                PostIncrementAssign = 79,
                PostDecrementAssign = 80,
                TypeEqual = 81,
                OnesComplement = 82,
                IsTrue = 83,
                IsFalse = 84
            }

            // System.Linq.Expressions.ExpressionVisitor
            export interface ExpressionVisitor extends Object {
                Visit$1(node: Expression): Expression;
                Visit(nodes: Collections.Generic.List$1<Expression>): Collections.Generic.List$1<Expression>;
                VisitAndConvert$1<T>(T, node: T, callerName: string): T;
                VisitAndConvert<T>(T, nodes: Collections.Generic.List$1<T>, callerName: string): Collections.Generic.List$1<T>;
            }
            export interface ExpressionVisitorTypeFunc extends TypeFunction {
                prototype: ExpressionVisitor;
                Visit<T>(T, nodes: Collections.Generic.List$1<T>, elementVisitor: Func$2<T, T>): Collections.Generic.List$1<T>;
            }
            var ExpressionVisitor: ExpressionVisitorTypeFunc;

            // System.Linq.Expressions.FieldExpression
            export interface FieldExpression extends MemberExpression {
            }
            export interface FieldExpressionTypeFunc extends TypeFunction {
                prototype: FieldExpression;
                ctor: { new (expression: Expression, member: Reflection.FieldInfo): FieldExpression };
            }
            var FieldExpression: FieldExpressionTypeFunc;

            // System.Linq.Expressions.IndexExpression
            export interface IndexExpression extends Expression {
                get_Object(): Expression;
                get_Indexer(): Reflection.PropertyInfo;
                get_Arguments(): Collections.Generic.List$1<Expression>;
            }
            export interface IndexExpressionTypeFunc extends TypeFunction {
                prototype: IndexExpression;
                ctor: { new (obj: Expression, indexer: Reflection.PropertyInfo, elementType: Type, args: Collections.Generic.List$1<Expression>): IndexExpression };
            }
            var IndexExpression: IndexExpressionTypeFunc;

            // System.Linq.Expressions.InvocationExpression
            export interface InvocationExpression extends Expression {
                get_Expression(): Expression;
                get_Arguments(): Collections.Generic.List$1<Expression>;
            }
            export interface InvocationExpressionTypeFunc extends TypeFunction {
                prototype: InvocationExpression;
                ctor: { new (expression: Expression, args: Collections.Generic.List$1<Expression>, returnType: Type): InvocationExpression };
            }
            var InvocationExpression: InvocationExpressionTypeFunc;

            // System.Linq.Expressions.LambdaExpression
            export interface LambdaExpression extends Expression {
                get_Name(): string;
                get_Body(): Expression;
                get_Parameters(): Collections.Generic.List$1<ParameterExpression>;
                get_DelegateType(): Type;
                get_TailCall(): boolean;
                Update(body: Expression, parameters: Collections.Generic.List$1<ParameterExpression>): LambdaExpression;
                Compile(): Delegate;
            }
            export interface LambdaExpressionTypeFunc extends TypeFunction {
                prototype: LambdaExpression;
            }
            var LambdaExpression: LambdaExpressionTypeFunc;

            // System.Linq.Expressions.ListInitExpression
            export interface ListInitExpression extends Expression {
                get_NewExpression(): NewExpression;
                get_Initializers(): Collections.Generic.List$1<ElementInit>;
                Update(NewExpression: NewExpression, initializers: Collections.Generic.List$1<ElementInit>): ListInitExpression;
            }
            export interface ListInitExpressionTypeFunc extends TypeFunction {
                prototype: ListInitExpression;
                ctor: { new (newExpression: NewExpression, initializers: Collections.Generic.List$1<ElementInit>): ListInitExpression };
            }
            var ListInitExpression: ListInitExpressionTypeFunc;

            // System.Linq.Expressions.MemberAssignment
            export interface MemberAssignment extends MemberBinding {
                get_Expression(): Expression;
                Update(Expression: Expression): MemberAssignment;
            }
            export interface MemberAssignmentTypeFunc extends TypeFunction {
                prototype: MemberAssignment;
                ctor: { new (member: Reflection.MemberInfo, expression: Expression): MemberAssignment };
            }
            var MemberAssignment: MemberAssignmentTypeFunc;

            // System.Linq.Expressions.MemberBinding
            export interface MemberBinding extends Object {
                get_BindingType(): MemberBindingType;
                get_Member(): Reflection.MemberInfo;
            }
            export interface MemberBindingTypeFunc extends TypeFunction {
                prototype: MemberBinding;
                ctor: { new (bindingType: MemberBindingType, member: Reflection.MemberInfo): MemberBinding };
            }
            var MemberBinding: MemberBindingTypeFunc;

            // System.Linq.Expressions.MemberBindingType
            export enum MemberBindingType {
                Assignment = 0,
                MemberBinding = 1,
                ListBinding = 2
            }

            // System.Linq.Expressions.MemberExpression
            export interface MemberExpression extends Expression {
                get_Expression(): Expression;
                get_Member(): Reflection.MemberInfo;
                Update(Expression: Expression): Expression;
            }
            export interface MemberExpressionTypeFunc extends TypeFunction {
                prototype: MemberExpression;
                ctor: { new (expression: Expression, member: Reflection.MemberInfo): MemberExpression };
            }
            var MemberExpression: MemberExpressionTypeFunc;

            // System.Linq.Expressions.MemberInitExpression
            export interface MemberInitExpression extends Expression {
                get_NewExpression(): NewExpression;
                get_Bindings(): Collections.Generic.List$1<MemberBinding>;
                Update(newExpression: NewExpression, bindings: Collections.Generic.List$1<MemberBinding>): MemberInitExpression;
            }
            export interface MemberInitExpressionTypeFunc extends TypeFunction {
                prototype: MemberInitExpression;
                ctor: { new (newExpression: NewExpression, bindings: Collections.Generic.List$1<MemberBinding>): MemberInitExpression };
            }
            var MemberInitExpression: MemberInitExpressionTypeFunc;

            // System.Linq.Expressions.MemberListBinding
            export interface MemberListBinding extends MemberBinding {
                get_Initializers(): Collections.Generic.List$1<ElementInit>;
                Update(initializers: Collections.Generic.List$1<ElementInit>): MemberListBinding;
            }
            export interface MemberListBindingTypeFunc extends TypeFunction {
                prototype: MemberListBinding;
                ctor: { new (bindingType: MemberBindingType, member: Reflection.MemberInfo, initializers: Collections.Generic.List$1<ElementInit>): MemberListBinding };
            }
            var MemberListBinding: MemberListBindingTypeFunc;

            // System.Linq.Expressions.MemberMemberBinding
            export interface MemberMemberBinding extends MemberBinding {
                get_Bindings(): Collections.Generic.List$1<MemberBinding>;
                Update(bindings: Collections.Generic.List$1<MemberBinding>): MemberMemberBinding;
            }
            export interface MemberMemberBindingTypeFunc extends TypeFunction {
                prototype: MemberMemberBinding;
                ctor: { new (bindingType: MemberBindingType, member: Reflection.MemberInfo, bindings: Collections.Generic.List$1<MemberBinding>): MemberMemberBinding };
            }
            var MemberMemberBinding: MemberMemberBindingTypeFunc;

            // System.Linq.Expressions.MethodCallExpression
            export interface MethodCallExpression extends Expression {
                get_Object(): Expression;
                get_Method(): Reflection.MethodInfo;
                get_Arguments(): Collections.Generic.List$1<Expression>;
            }
            export interface MethodCallExpressionTypeFunc extends TypeFunction {
                prototype: MethodCallExpression;
                ctor: { new (obj: Expression, method: Reflection.MethodInfo, args: Expression[]): MethodCallExpression };
            }
            var MethodCallExpression: MethodCallExpressionTypeFunc;

            // System.Linq.Expressions.NewArrayExpression
            export interface NewArrayExpression extends Expression {
                get_Expressions(): Collections.Generic.List$1<Expression>;
                Update(expressions: Collections.Generic.List$1<Expression>): Expression;
            }
            export interface NewArrayExpressionTypeFunc extends TypeFunction {
                prototype: NewArrayExpression;
                ctor: { new (nodeType: ExpressionType, type: Type, expressions: Collections.Generic.List$1<Expression>): NewArrayExpression };
            }
            var NewArrayExpression: NewArrayExpressionTypeFunc;

            // System.Linq.Expressions.NewExpression
            export interface NewExpression extends Expression {
                get_Arguments(): Collections.Generic.List$1<Expression>;
                get_Constructor(): Reflection.ConstructorInfo;
                Update(args: Collections.Generic.List$1<Expression>): Expression;
            }
            export interface NewExpressionTypeFunc extends TypeFunction {
                prototype: NewExpression;
                ctor: { new (constructor: Reflection.ConstructorInfo, args: Collections.Generic.IEnumerable$1<Expression>): NewExpression };
            }
            var NewExpression: NewExpressionTypeFunc;

            // System.Linq.Expressions.ParameterExpression
            export interface ParameterExpression extends Expression {
                get_ParameterType(): Type;
                get_Name(): string;
            }
            export interface ParameterExpressionTypeFunc extends TypeFunction {
                prototype: ParameterExpression;
                ctor: { new (parameterType: Type, name: string): ParameterExpression };
            }
            var ParameterExpression: ParameterExpressionTypeFunc;

            // System.Linq.Expressions.PropertyExpression
            export interface PropertyExpression extends MemberExpression {
            }
            export interface PropertyExpressionTypeFunc extends TypeFunction {
                prototype: PropertyExpression;
                ctor: { new (expression: Expression, member: Reflection.PropertyInfo): PropertyExpression };
            }
            var PropertyExpression: PropertyExpressionTypeFunc;

            // System.Linq.Expressions.TypeBinaryExpression
            export interface TypeBinaryExpression extends Expression {
                get_Expression(): Expression;
                get_TypeOperand(): Type;
                Update(expression: Expression): Expression;
            }
            export interface TypeBinaryExpressionTypeFunc extends TypeFunction {
                prototype: TypeBinaryExpression;
                ctor: { new (expression: Expression, typeOperand: Type, nodeKind: ExpressionType): TypeBinaryExpression };
            }
            var TypeBinaryExpression: TypeBinaryExpressionTypeFunc;

            // System.Linq.Expressions.UnaryExpression
            export interface UnaryExpression extends Expression {
                get_Operand(): Expression;
                get_Method(): Reflection.MethodInfo;
                Update(operand: Expression): UnaryExpression;
            }
            export interface UnaryExpressionTypeFunc extends TypeFunction {
                prototype: UnaryExpression;
                ctor: { new (nodeType: ExpressionType, operand: Expression, method: Reflection.MethodInfo, type: Type): UnaryExpression };
            }
            var UnaryExpression: UnaryExpressionTypeFunc;
        }
    }
    module Reflection {
        // System.Reflection.Assembly
        export interface Assembly extends Object, ICustomAttributeProvider {
            GetManifestResourceString(name: string, decodeAsAscii: boolean): string;
            GetManifestResourceBytes(name: string): byte[];
            GetManifestResourceNames(): string[];
            GetManifestResourceStream(name: string): IO.Stream;
            get_CodeBase(): string;
            get_FullName(): string;
            get_EntryPoint(): MethodInfo;
            get_Location(): string;
            GetName(): AssemblyName;
            GetName$1(copiedName: boolean): AssemblyName;
            GetType$1(name: string): Type;
            GetType$2(name: string, throwOnError: boolean): Type;
            GetType$3(name: string, throwOnError: boolean, ignoreCase: boolean): Type;
            GetTypes(): Type[];
            GetCustomAttributes(inherit: boolean): any[];
            GetCustomAttributes$1(attributeType: Type, inherit: boolean): any[];
            IsDefined(attributeType: Type, inherit: boolean): boolean;
            CreateInstance(typeName: string): any;
            CreateInstance$1(typeName: string, ignoreCase: boolean): any;
            CreateInstance$2(typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: any[], culture: Globalization.CultureInfo, activationAttributes: any[]): any;
            GetReferencedAssemblies(): AssemblyName[];
        }
        export interface AssemblyTypeFunc extends TypeFunction {
            prototype: Assembly;
            CreateQualifiedName(assemblyName: string, typeName: string): string;
            GetAssembly(type: Type): Assembly;
            GetExecutingAssembly(): Assembly;
            GetCallingAssembly(): Assembly;
            GetEntryAssembly(): Assembly;
            Load(name: string): Assembly;
        }
        var Assembly: AssemblyTypeFunc;

        // System.Reflection.AssemblyCompanyAttribute
        export interface AssemblyCompanyAttribute extends Attribute {
            get_Company(): string;
        }
        export interface AssemblyCompanyAttributeTypeFunc extends TypeFunction {
            prototype: AssemblyCompanyAttribute;
            ctor: { new (company: string): AssemblyCompanyAttribute };
        }
        var AssemblyCompanyAttribute: AssemblyCompanyAttributeTypeFunc;

        // System.Reflection.AssemblyConfigurationAttribute
        export interface AssemblyConfigurationAttribute extends Attribute {
            get_Configuration(): string;
        }
        export interface AssemblyConfigurationAttributeTypeFunc extends TypeFunction {
            prototype: AssemblyConfigurationAttribute;
            ctor: { new (configuration: string): AssemblyConfigurationAttribute };
        }
        var AssemblyConfigurationAttribute: AssemblyConfigurationAttributeTypeFunc;

        // System.Reflection.AssemblyCopyrightAttribute
        export interface AssemblyCopyrightAttribute extends Attribute {
            get_Copyright(): string;
        }
        export interface AssemblyCopyrightAttributeTypeFunc extends TypeFunction {
            prototype: AssemblyCopyrightAttribute;
            ctor: { new (copyright: string): AssemblyCopyrightAttribute };
        }
        var AssemblyCopyrightAttribute: AssemblyCopyrightAttributeTypeFunc;

        // System.Reflection.AssemblyCultureAttribute
        export interface AssemblyCultureAttribute extends Attribute {
            get_Culture(): string;
        }
        export interface AssemblyCultureAttributeTypeFunc extends TypeFunction {
            prototype: AssemblyCultureAttribute;
            ctor: { new (culture: string): AssemblyCultureAttribute };
        }
        var AssemblyCultureAttribute: AssemblyCultureAttributeTypeFunc;

        // System.Reflection.AssemblyDescriptionAttribute
        export interface AssemblyDescriptionAttribute extends Attribute {
            get_Description(): string;
        }
        export interface AssemblyDescriptionAttributeTypeFunc extends TypeFunction {
            prototype: AssemblyDescriptionAttribute;
            ctor: { new (description: string): AssemblyDescriptionAttribute };
        }
        var AssemblyDescriptionAttribute: AssemblyDescriptionAttributeTypeFunc;

        // System.Reflection.AssemblyFileVersionAttribute
        export interface AssemblyFileVersionAttribute extends Attribute {
            get_Version(): string;
        }
        export interface AssemblyFileVersionAttributeTypeFunc extends TypeFunction {
            prototype: AssemblyFileVersionAttribute;
            ctor: { new (version: string): AssemblyFileVersionAttribute };
        }
        var AssemblyFileVersionAttribute: AssemblyFileVersionAttributeTypeFunc;

        // System.Reflection.AssemblyName
        export interface AssemblyName extends Object {
            get_Name(): string;
            set_Name(value: string): void;
            get_CultureInfo(): Globalization.CultureInfo;
            set_CultureInfo(value: Globalization.CultureInfo): void;
            get_CultureName(): string;
            get_CodeBase(): string;
            set_CodeBase(value: string): void;
            get_FullName(): string;
        }
        export interface AssemblyNameTypeFunc extends TypeFunction {
            prototype: AssemblyName;
            ctor: { new (): AssemblyName };
            ctor$1: { new (assemblyName: string): AssemblyName };
        }
        var AssemblyName: AssemblyNameTypeFunc;

        // System.Reflection.AssemblyProductAttribute
        export interface AssemblyProductAttribute extends Attribute {
            get_Product(): string;
        }
        export interface AssemblyProductAttributeTypeFunc extends TypeFunction {
            prototype: AssemblyProductAttribute;
            ctor: { new (product: string): AssemblyProductAttribute };
        }
        var AssemblyProductAttribute: AssemblyProductAttributeTypeFunc;

        // System.Reflection.AssemblyTitleAttribute
        export interface AssemblyTitleAttribute extends Attribute {
            get_Title(): string;
        }
        export interface AssemblyTitleAttributeTypeFunc extends TypeFunction {
            prototype: AssemblyTitleAttribute;
            ctor: { new (title: string): AssemblyTitleAttribute };
        }
        var AssemblyTitleAttribute: AssemblyTitleAttributeTypeFunc;

        // System.Reflection.AssemblyTrademarkAttribute
        export interface AssemblyTrademarkAttribute extends Attribute {
            get_Trademark(): string;
        }
        export interface AssemblyTrademarkAttributeTypeFunc extends TypeFunction {
            prototype: AssemblyTrademarkAttribute;
            ctor: { new (trademark: string): AssemblyTrademarkAttribute };
        }
        var AssemblyTrademarkAttribute: AssemblyTrademarkAttributeTypeFunc;

        // System.Reflection.AssemblyVersionAttribute
        export interface AssemblyVersionAttribute extends Attribute {
            get_Version(): string;
        }
        export interface AssemblyVersionAttributeTypeFunc extends TypeFunction {
            prototype: AssemblyVersionAttribute;
            ctor: { new (version: string): AssemblyVersionAttribute };
        }
        var AssemblyVersionAttribute: AssemblyVersionAttributeTypeFunc;

        // System.Reflection.Binder
        export interface Binder extends Object {
        }
        export interface BinderTypeFunc extends TypeFunction {
            prototype: Binder;
            ctor: { new (): Binder };
        }
        var Binder: BinderTypeFunc;

        // System.Reflection.BindingFlags
        export enum BindingFlags {
            Default = 0,
            IgnoreCase = 1,
            DeclaredOnly = 2,
            Instance = 4,
            Static = 8,
            Public = 16,
            NonPublic = 32,
            FlattenHierarchy = 64,
            InvokeMethod = 256,
            CreateInstance = 512,
            GetField = 1024,
            SetField = 2048,
            GetProperty = 4096,
            SetProperty = 8192,
            PutDispProperty = 16384,
            PutRefDispProperty = 32768,
            ExactBinding = 65536,
            SuppressChangeType = 131072,
            OptionalParamBinding = 262144,
            IgnoreReturn = 16777216
        }

        // System.Reflection.CallingConventions
        export enum CallingConventions {
            Standard = 1,
            VarArgs = 2,
            Any = 3,
            HasThis = 32,
            ExplicitThis = 64
        }

        // System.Reflection.ConstructorInfo
        export interface ConstructorInfo extends MethodBase, ICustomAttributeProvider {
            Invoke$3(invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: Globalization.CultureInfo): any;
            Invoke$2(parameters: any[]): any;
        }
        export interface ConstructorInfoTypeFunc extends TypeFunction {
            prototype: ConstructorInfo;
            ConstructorName: string;
            TypeConstructorName: string;
            ctor: { new (name: string, jsConstructor: Function, methodAttributes: MethodAttributes, parameters: Array<ParameterInfo>, attributes: Array<Attribute>): ConstructorInfo };
        }
        var ConstructorInfo: ConstructorInfoTypeFunc;

        // System.Reflection.EventInfo
        export interface EventInfo extends MemberInfo, ICustomAttributeProvider {
            get_AddMethod(): MethodInfo;
            get_RemoveMethod(): MethodInfo;
            get_EventHandlerType(): Type;
            GetAddMethod$1(nonPublic: boolean): MethodInfo;
            GetRemoveMethod$1(nonPublic: boolean): MethodInfo;
            GetAddMethod(): MethodInfo;
            GetRemoveMethod(): MethodInfo;
            AddEventHandler(target: any, handler: Delegate): void;
            RemoveEventHandler(target: any, handler: Delegate): void;
        }
        export interface EventInfoTypeFunc extends TypeFunction {
            prototype: EventInfo;
        }
        var EventInfo: EventInfoTypeFunc;

        // System.Reflection.FieldAttributes
        export enum FieldAttributes {
            FieldAccessMask = 7,
            PrivateScope = 0,
            Private = 1,
            FamANDAssem = 2,
            Assembly = 3,
            Family = 4,
            FamORAssem = 5,
            Public = 6,
            Static = 16,
            InitOnly = 32,
            Literal = 64,
            NotSerialized = 128,
            SpecialName = 512,
            PinvokeImpl = 8192,
            ReservedMask = 38144,
            RTSpecialName = 1024,
            HasFieldMarshal = 4096,
            HasDefault = 32768,
            HasFieldRVA = 256
        }

        // System.Reflection.FieldInfo
        export interface FieldInfo extends MemberInfo, ICustomAttributeProvider {
            get_FieldType(): Type;
            get_Attributes(): FieldAttributes;
            get_IsPublic(): boolean;
            get_IsPrivate(): boolean;
            get_IsFamily(): boolean;
            get_IsAssembly(): boolean;
            get_IsFamilyAndAssembly(): boolean;
            get_IsFamilyOrAssembly(): boolean;
            get_IsStatic(): boolean;
            get_IsInitOnly(): boolean;
            get_IsLiteral(): boolean;
            get_IsNotSerialized(): boolean;
            get_IsSpecialName(): boolean;
            get_IsPinvokeImpl(): boolean;
            GetRequiredCustomModifiers(): Type[];
            GetOptionalCustomModifiers(): Type[];
            GetValue(obj: any): any;
            SetValue$1(obj: any, value: any, invokeAttr: BindingFlags, binder: Binder, culture: Globalization.CultureInfo): void;
            GetRawConstantValue(): any;
            SetValue(obj: any, value: any): void;
        }
        export interface FieldInfoTypeFunc extends TypeFunction {
            prototype: FieldInfo;
        }
        var FieldInfo: FieldInfoTypeFunc;

        // System.Reflection.ICustomAttributeProvider
        export interface ICustomAttributeProvider {
            System$Reflection$ICustomAttributeProvider$GetCustomAttributes$1(attributeType: Type, inherit: boolean): any[];
            System$Reflection$ICustomAttributeProvider$GetCustomAttributes(inherit: boolean): any[];
            System$Reflection$ICustomAttributeProvider$IsDefined(attributeType: Type, inherit: boolean): boolean;
        }
        var ICustomAttributeProvider: TypeFunction;

        // System.Reflection.MemberInfo
        export interface MemberInfo extends Object, ICustomAttributeProvider {
            get_MemberType(): MemberTypes;
            get_Name(): string;
            get_DeclaringType(): Type;
            GetCustomAttributes(inherit: boolean): any[];
            GetCustomAttributes$1(attributeType: Type, inherit: boolean): any[];
            IsDefined(attributeType: Type, inherit: boolean): boolean;
        }
        export interface MemberInfoTypeFunc extends TypeFunction {
            prototype: MemberInfo;
        }
        var MemberInfo: MemberInfoTypeFunc;

        // System.Reflection.MemberTypes
        export enum MemberTypes {
            Constructor = 1,
            Event = 2,
            Field = 4,
            Method = 8,
            Property = 16,
            TypeInfo = 32,
            Custom = 64,
            NestedType = 128,
            All = 191
        }

        // System.Reflection.MethodAttributes
        export enum MethodAttributes {
            MemberAccessMask = 7,
            PrivateScope = 0,
            Private = 1,
            FamANDAssem = 2,
            Assembly = 3,
            Family = 4,
            FamORAssem = 5,
            Public = 6,
            Static = 16,
            Final = 32,
            Virtual = 64,
            HideBySig = 128,
            CheckAccessOnOverride = 512,
            VtableLayoutMask = 256,
            Abstract = 1024,
            SpecialName = 2048,
            PinvokeImpl = 8192,
            UnmanagedExport = 8,
            RTSpecialName = 4096,
            ReservedMask = 53248,
            HasSecurity = 16384,
            RequireSecObject = 32768
        }

        // System.Reflection.MethodBase
        export interface MethodBase extends MemberInfo, ICustomAttributeProvider {
            get_Attributes(): MethodAttributes;
            get_CallingConvention(): CallingConventions;
            get_IsGenericMethodDefinition(): boolean;
            get_ContainsGenericParameters(): boolean;
            get_IsGenericMethod(): boolean;
            get_IsSecurityCritical(): boolean;
            get_IsSecuritySafeCritical(): boolean;
            get_IsSecurityTransparent(): boolean;
            get_IsPublic(): boolean;
            get_IsPrivate(): boolean;
            get_IsFamily(): boolean;
            get_IsAssembly(): boolean;
            get_IsFamilyAndAssembly(): boolean;
            get_IsFamilyOrAssembly(): boolean;
            get_IsStatic(): boolean;
            get_IsFinal(): boolean;
            get_IsVirtual(): boolean;
            get_IsHideBySig(): boolean;
            get_IsAbstract(): boolean;
            get_IsSpecialName(): boolean;
            get_IsConstructor(): boolean;
            GetParameters(): ParameterInfo[];
            Invoke$1(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: Globalization.CultureInfo): any;
            GetGenericArguments(): Type[];
            Invoke(obj: any, parameters: any[]): any;
        }
        export interface MethodBaseTypeFunc extends TypeFunction {
            prototype: MethodBase;
            GetCurrentMethod(): MethodBase;
        }
        var MethodBase: MethodBaseTypeFunc;

        // System.Reflection.MethodInfo
        export interface MethodInfo extends MethodBase, ICustomAttributeProvider {
            get_ReturnType(): Type;
            get_ReturnTypeCustomAttributes(): ICustomAttributeProvider;
            GetBaseDefinition(): MethodInfo;
            GetGenericMethodDefinition(): MethodInfo;
            MakeGenericMethod(typeArguments: Type[]): MethodInfo;
            CreateDelegate(delegateType: Type): Delegate;
            CreateDelegate$1(delegateType: Type, target: any): Delegate;
        }
        export interface MethodInfoTypeFunc extends TypeFunction {
            prototype: MethodInfo;
        }
        var MethodInfo: MethodInfoTypeFunc;

        // System.Reflection.ParameterAttributes
        export enum ParameterAttributes {
            None = 0,
            In = 1,
            Out = 2,
            Lcid = 4,
            Retval = 8,
            Optional = 16,
            ReservedMask = 61440,
            HasDefault = 4096,
            HasFieldMarshal = 8192,
            Reserved3 = 16384,
            Reserved4 = 32768
        }

        // System.Reflection.ParameterInfo
        export interface ParameterInfo extends Object, ICustomAttributeProvider {
            get_ParameterType(): Type;
            get_Name(): string;
            get_HasDefaultValue(): boolean;
            get_DefaultValue(): any;
            get_RawDefaultValue(): any;
            get_Position(): int;
            get_Attributes(): ParameterAttributes;
            get_Member(): MemberInfo;
            get_IsIn(): boolean;
            get_IsOut(): boolean;
            get_IsLcid(): boolean;
            get_IsRetval(): boolean;
            get_IsOptional(): boolean;
            GetCustomAttributes(inherit: boolean): any[];
            GetCustomAttributes$1(attributeType: Type, inherit: boolean): any[];
            IsDefined(attributeType: Type, inherit: boolean): boolean;
        }
        export interface ParameterInfoTypeFunc extends TypeFunction {
            prototype: ParameterInfo;
        }
        var ParameterInfo: ParameterInfoTypeFunc;

        // System.Reflection.ParameterModifier
        export interface ParameterModifier extends ValueType {
            get_Item(index: int): boolean;
            set_Item(index: int, value: boolean): void;
        }
        export interface ParameterModifierTypeFunc extends TypeFunction {
            prototype: ParameterModifier;
            ctor$1: { new (parameterCount: int): ParameterModifier };
            ctor: { new (): ParameterModifier };
        }
        var ParameterModifier: ParameterModifierTypeFunc;

        // System.Reflection.PropertyAttributes
        export enum PropertyAttributes {
            None = 0,
            SpecialName = 512,
            ReservedMask = 62464,
            RTSpecialName = 1024,
            HasDefault = 4096,
            Reserved2 = 8192,
            Reserved3 = 16384,
            Reserved4 = 32768
        }

        // System.Reflection.PropertyInfo
        export interface PropertyInfo extends MemberInfo, ICustomAttributeProvider {
            get_PropertyType(): Type;
            get_Attributes(): PropertyAttributes;
            get_CanRead(): boolean;
            get_CanWrite(): boolean;
            get_GetMethod(): MethodInfo;
            get_SetMethod(): MethodInfo;
            get_IsSpecialName(): boolean;
            SetValue$2(obj: any, value: any, invokeAttr: BindingFlags, binder: Binder, index: any[], culture: Globalization.CultureInfo): void;
            GetAccessors$1(nonPublic: boolean): MethodInfo[];
            GetGetMethod$1(nonPublic: boolean): MethodInfo;
            GetSetMethod$1(nonPublic: boolean): MethodInfo;
            GetIndexParameters(): ParameterInfo[];
            GetValue(obj: any): any;
            GetValue$1(obj: any, index: any[]): any;
            GetValue$2(obj: any, invokeAttr: BindingFlags, binder: Binder, index: any[], culture: Globalization.CultureInfo): any;
            SetValue(obj: any, value: any): void;
            SetValue$1(obj: any, value: any, index: any[]): void;
            GetRequiredCustomModifiers(): Type[];
            GetOptionalCustomModifiers(): Type[];
            GetAccessors(): MethodInfo[];
            GetGetMethod(): MethodInfo;
            GetSetMethod(): MethodInfo;
        }
        export interface PropertyInfoTypeFunc extends TypeFunction {
            prototype: PropertyInfo;
        }
        var PropertyInfo: PropertyInfoTypeFunc;

        // System.Reflection.TypeAttributes
        export enum TypeAttributes {
            VisibilityMask = 7,
            NotPublic = 0,
            Public = 1,
            NestedPublic = 2,
            NestedPrivate = 3,
            NestedFamily = 4,
            NestedAssembly = 5,
            NestedFamANDAssem = 6,
            NestedFamORAssem = 7,
            LayoutMask = 24,
            AutoLayout = 0,
            SequentialLayout = 8,
            ExplicitLayout = 16,
            ClassSemanticsMask = 32,
            Class = 0,
            Interface = 32,
            Abstract = 128,
            Sealed = 256,
            SpecialName = 1024,
            Import = 4096,
            Serializable = 8192,
            StringFormatMask = 196608,
            AnsiClass = 0,
            UnicodeClass = 65536,
            AutoClass = 131072,
            CustomFormatClass = 196608,
            CustomFormatMask = 12582912,
            BeforeFieldInit = 1048576,
            ReservedMask = 264192,
            RTSpecialName = 2048,
            HasSecurity = 262144,
            Unknown = 2097152
        }
    }
    module Resources {
        // System.Resources.ResourceManager
        export interface ResourceManager extends Object {
            GetString(name: string, cultureInfo: Globalization.CultureInfo): string;
            GetObject(name: string, cultureInfo: Globalization.CultureInfo): any;
        }
        export interface ResourceManagerTypeFunc extends TypeFunction {
            prototype: ResourceManager;
            ctor: { new (name: string, assembly: Reflection.Assembly): ResourceManager };
        }
        var ResourceManager: ResourceManagerTypeFunc;
    }
    module Runtime {
        module CompilerServices {
            // System.Runtime.CompilerServices.AsyncTaskMethodBuilder
            export interface AsyncTaskMethodBuilder extends ValueType {
                get_Task(): Threading.Tasks.Task;
                Start<TStateMachine>(TStateMachine, stateMachine: TStateMachine): void;
                SetStateMachine(stateMachine: IAsyncStateMachine): void;
                AwaitOnCompleted<TAwaiter, TStateMachine>(TAwaiter, TStateMachine, awaiter: TAwaiter, stateMachine: TStateMachine): void;
                SetResult(): void;
                SetException(exception: Exception): void;
                AwaitOnCompleted$1<TAwaiter, TStateMachine>(TAwaiter, TStateMachine, awaiter: TAwaiter, stateMachine: TStateMachine): void;
                AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(TAwaiter, TStateMachine, awaiter: TAwaiter, stateMachine: TStateMachine): void;
            }
            export interface AsyncTaskMethodBuilderTypeFunc extends TypeFunction {
                prototype: AsyncTaskMethodBuilder;
                ctor: { new (): AsyncTaskMethodBuilder };
                Create(): AsyncTaskMethodBuilder;
            }
            var AsyncTaskMethodBuilder: AsyncTaskMethodBuilderTypeFunc;

            // System.Runtime.CompilerServices.AsyncTaskMethodBuilder<TResult>
            export interface AsyncTaskMethodBuilder$1<TResult> extends ValueType {
                get_Task(): Threading.Tasks.Task$1<TResult>;
                Start<TStateMachine>(TStateMachine, stateMachine: TStateMachine): void;
                SetStateMachine(stateMachine: IAsyncStateMachine): void;
                AwaitOnCompleted<TAwaiter, TStateMachine>(TAwaiter, TStateMachine, awaiter: TAwaiter, stateMachine: TStateMachine): void;
                SetResult(result: TResult): void;
                SetException(exception: Exception): void;
                AwaitOnCompleted$1<TAwaiter, TStateMachine>(TAwaiter, TStateMachine, awaiter: TAwaiter, stateMachine: TStateMachine): void;
                AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(TAwaiter, TStateMachine, awaiter: TAwaiter, stateMachine: TStateMachine): void;
            }
            export interface AsyncTaskMethodBuilder$1TypeFunc<TResult> extends TypeFunction {
                (TResult): {
                    prototype: AsyncTaskMethodBuilder$1<TResult>;
                    ctor: { new (): AsyncTaskMethodBuilder$1<TResult> };
                    Create(): AsyncTaskMethodBuilder$1<TResult>;
                }
            }
            var AsyncTaskMethodBuilder$1: AsyncTaskMethodBuilder$1TypeFunc<any>;

            // System.Runtime.CompilerServices.AsyncVoidMethodBuilder
            export interface AsyncVoidMethodBuilder extends ValueType {
                Start<TStateMachine>(TStateMachine, stateMachine: TStateMachine): void;
                SetStateMachine(stateMachine: IAsyncStateMachine): void;
                AwaitOnCompleted<TAwaiter, TStateMachine>(TAwaiter, TStateMachine, awaiter: TAwaiter, stateMachine: TStateMachine): void;
                AwaitOnCompleted$1<TAwaiter, TStateMachine>(TAwaiter, TStateMachine, awaiter: TAwaiter, stateMachine: TStateMachine): void;
                AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(TAwaiter, TStateMachine, awaiter: TAwaiter, stateMachine: TStateMachine): void;
                SetResult(): void;
                SetException(exception: Exception): void;
            }
            export interface AsyncVoidMethodBuilderTypeFunc extends TypeFunction {
                prototype: AsyncVoidMethodBuilder;
                ctor: { new (): AsyncVoidMethodBuilder };
                Create(): AsyncVoidMethodBuilder;
            }
            var AsyncVoidMethodBuilder: AsyncVoidMethodBuilderTypeFunc;

            // System.Runtime.CompilerServices.IAsyncStateMachine
            export interface IAsyncStateMachine {
                System$Runtime$CompilerServices$IAsyncStateMachine$MoveNext(): void;
                System$Runtime$CompilerServices$IAsyncStateMachine$SetStateMachine(stateMachine: IAsyncStateMachine): void;
            }
            var IAsyncStateMachine: TypeFunction;

            // System.Runtime.CompilerServices.ICriticalNotifyCompletion
            export interface ICriticalNotifyCompletion extends INotifyCompletion {
                System$Runtime$CompilerServices$ICriticalNotifyCompletion$UnsafeOnCompleted(continuation: Action): void;
            }
            var ICriticalNotifyCompletion: TypeFunction;

            // System.Runtime.CompilerServices.IndexerNameAttribute
            export interface IndexerNameAttribute extends Attribute {
            }
            export interface IndexerNameAttributeTypeFunc extends TypeFunction {
                prototype: IndexerNameAttribute;
                ctor: { new (indexerName: string): IndexerNameAttribute };
            }
            var IndexerNameAttribute: IndexerNameAttributeTypeFunc;

            // System.Runtime.CompilerServices.INotifyCompletion
            export interface INotifyCompletion {
                System$Runtime$CompilerServices$INotifyCompletion$OnCompleted(continuation: Action): void;
            }
            var INotifyCompletion: TypeFunction;

            // System.Runtime.CompilerServices.OperationCanceledException
            export interface OperationCanceledException extends Exception {
                get_CancellationToken(): Threading.CancellationToken;
                set_CancellationToken(value: Threading.CancellationToken): void;
            }
            export interface OperationCanceledExceptionTypeFunc extends TypeFunction {
                prototype: OperationCanceledException;
                ctor: { new (): OperationCanceledException };
            }
            var OperationCanceledException: OperationCanceledExceptionTypeFunc;

            // System.Runtime.CompilerServices.RuntimeWrappedException
            export interface RuntimeWrappedException extends Exception {
                get_WrappedException(): any;
            }
            export interface RuntimeWrappedExceptionTypeFunc extends TypeFunction {
                prototype: RuntimeWrappedException;
            }
            var RuntimeWrappedException: RuntimeWrappedExceptionTypeFunc;

            // System.Runtime.CompilerServices.TaskAwaiter
            export interface TaskAwaiter extends ValueType, ICriticalNotifyCompletion, INotifyCompletion {
                get_IsCompleted(): boolean;
                OnCompleted(continuation: Action): void;
                UnsafeOnCompleted(continuation: Action): void;
                GetResult(): void;
            }
            export interface TaskAwaiterTypeFunc extends TypeFunction {
                prototype: TaskAwaiter;
                ctor: { new (): TaskAwaiter };
            }
            var TaskAwaiter: TaskAwaiterTypeFunc;

            // System.Runtime.CompilerServices.TaskAwaiter<TResult>
            export interface TaskAwaiter$1<TResult> extends ValueType, ICriticalNotifyCompletion, INotifyCompletion {
                get_IsCompleted(): boolean;
                OnCompleted(continuation: Action): void;
                UnsafeOnCompleted(continuation: Action): void;
                GetResult(): TResult;
            }
            export interface TaskAwaiter$1TypeFunc<TResult> extends TypeFunction {
                (TResult): {
                    prototype: TaskAwaiter$1<TResult>;
                    ctor$1: { new (mTask: Threading.Tasks.Task$1<TResult>): TaskAwaiter$1<TResult> };
                    ctor: { new (): TaskAwaiter$1<TResult> };
                }
            }
            var TaskAwaiter$1: TaskAwaiter$1TypeFunc<any>;
        }
        module ExceptionServices {
            // System.Runtime.ExceptionServices.ExceptionDispatchInfo
            export interface ExceptionDispatchInfo extends Object {
                get_SourceException(): Exception;
                Throw(): void;
            }
            export interface ExceptionDispatchInfoTypeFunc extends TypeFunction {
                prototype: ExceptionDispatchInfo;
                Capture(source: Exception): ExceptionDispatchInfo;
            }
            var ExceptionDispatchInfo: ExceptionDispatchInfoTypeFunc;
        }
        module Serialization {
            // System.Runtime.Serialization.ISerializable
            export interface ISerializable {
                System$Runtime$Serialization$ISerializable$GetObjectData(info: any, context: any): void;
            }
            var ISerializable: TypeFunction;
        }
    }
    module Text {
        // System.Text.StringBuilder
        export interface StringBuilder extends Object {
            get_Item(index: int): char;
            get_Length(): int;
            set_Length(value: int): void;
            Append$12(s: string): StringBuilder;
            Append(value: boolean): StringBuilder;
            Append$10(value: sbyte): StringBuilder;
            Append$1(value: byte): StringBuilder;
            Append$11(value: short): StringBuilder;
            Append$7(value: int): StringBuilder;
            Append$8(value: long): StringBuilder;
            Append$6(value: float): StringBuilder;
            Append$5(value: double): StringBuilder;
            Append$4(value: decimal): StringBuilder;
            Append$15(value: ushort): StringBuilder;
            Append$13(value: uint): StringBuilder;
            Append$14(value: ulong): StringBuilder;
            Append$3(value: char[]): StringBuilder;
            Append$17(value: char[], startIndex: int, charCount: int): StringBuilder;
            Append$2(value: char): StringBuilder;
            Append$9(o: any): StringBuilder;
            AppendLine(): StringBuilder;
            AppendLine$1(s: string): StringBuilder;
            Append$18(value: string, startIndex: int, length: int): StringBuilder;
            AppendFormat$1(format: string, args: any[]): StringBuilder;
            AppendFormat(format: string, arg0: any): StringBuilder;
            AppendFormat$3(format: string, arg0: any, arg1: any): StringBuilder;
            AppendFormat$4(format: string, arg0: any, arg1: any, arg2: any): StringBuilder;
            AppendFormat$2(provider: IFormatProvider, format: string, args: any[]): StringBuilder;
            Append$16(value: char, repeatCount: int): StringBuilder;
            Clear(): StringBuilder;
        }
        export interface StringBuilderTypeFunc extends TypeFunction {
            prototype: StringBuilder;
            ctor: { new (): StringBuilder };
            ctor$1: { new (capacity: int): StringBuilder };
            ctor$3: { new (capacity: int, maxCapacity: int): StringBuilder };
            ctor$2: { new (initialText: string): StringBuilder };
        }
        var StringBuilder: StringBuilderTypeFunc;
    }
    module Threading {
        // System.Threading.CancellationToken
        export interface CancellationToken extends ValueType {
        }
        export interface CancellationTokenTypeFunc extends TypeFunction {
            prototype: CancellationToken;
            ctor: { new (): CancellationToken };
        }
        var CancellationToken: CancellationTokenTypeFunc;

        // System.Threading.Interlocked
        export interface Interlocked extends Object {
        }
        export interface InterlockedTypeFunc extends TypeFunction {
            prototype: Interlocked;
            ctor: { new (): Interlocked };
            CompareExchange<T>(T, location1: T, value: T, comparand: T): T;
            Exchange<T>(T, location1: T, value: T): T;
        }
        var Interlocked: InterlockedTypeFunc;
        module Tasks {
            // System.Threading.Tasks.Task
            export interface Task extends Object {
                get_IsCompleted(): boolean;
                get_IsFaulted(): boolean;
                GetAwaiter(): Runtime.CompilerServices.TaskAwaiter;
                Wait(continueWith: Action): void;
                ContinueWith$1<TResult>(TResult, continuationFunction: Func$2<Task, TResult>): Task$1<TResult>;
                ContinueWith(continuationAction: Action$1<Task>): Task;
            }
            export interface TaskTypeFunc extends TypeFunction {
                prototype: Task;
                ctor: { new (): Task };
                FromResult<TResult>(TResult, result: TResult): Task$1<TResult>;
            }
            var Task: TaskTypeFunc;

            // System.Threading.Tasks.Task<TResult>
            export interface Task$1<TResult> extends Task {
                GetAwaiter$1(): Runtime.CompilerServices.TaskAwaiter$1<TResult>;
                ContinueWith$2(continuationAction: Action$1<Task$1<TResult>>): Task;
                ContinueWith$3<TNewResult>(TNewResult, continuationFunction: Func$2<Task$1<TResult>, TNewResult>): Task$1<TNewResult>;
                get_Result(): TResult;
            }
            export interface Task$1TypeFunc<TResult> extends TypeFunction {
                (TResult): {
                    prototype: Task$1<TResult>;
                    ctor: { new (): Task$1<TResult> };
                    ctor$1: { new (mResult: TResult): Task$1<TResult> };
                }
            }
            var Task$1: Task$1TypeFunc<any>;

            // System.Threading.Tasks.TaskCompletionSource<TResult>
            export interface TaskCompletionSource$1<TResult> extends Object {
                get_Task(): Task$1<TResult>;
                TrySetException$1(exception: Exception): boolean;
                TrySetException(exceptions: Collections.Generic.IEnumerable$1<Exception>): boolean;
                SetException$1(exception: Exception): void;
                SetException(exceptions: Collections.Generic.IEnumerable$1<Exception>): void;
                TrySetResult(result: TResult): boolean;
                SetResult(result: TResult): void;
                TrySetCanceled(): boolean;
                SetCanceled(): void;
            }
            export interface TaskCompletionSource$1TypeFunc<TResult> extends TypeFunction {
                (TResult): {
                    prototype: TaskCompletionSource$1<TResult>;
                    ctor: { new (): TaskCompletionSource$1<TResult> };
                }
            }
            var TaskCompletionSource$1: TaskCompletionSource$1TypeFunc<any>;
        }
    }
    module Web {
        // System.Web.HttpUtility
        export interface HttpUtilityTypeFunc extends TypeFunction {
            UrlEncode(s: string): string;
            UrlDecode(s: string): string;
        }
        var HttpUtility: HttpUtilityTypeFunc;
    }
}
declare module DuoCode {
    module Runtime {
        // DuoCode.Runtime.CompilerAttribute
        export interface CompilerAttribute extends System.Attribute {
            Version: string;
        }
        export interface CompilerAttributeTypeFunc extends TypeFunction {
            prototype: CompilerAttribute;
            ctor: { new (version: string): CompilerAttribute };
        }
        var CompilerAttribute: CompilerAttributeTypeFunc;

        // DuoCode.Runtime.RuntimeFunctions
        var defaultOf: (type: Function) => any;
        var as: (obj: any, dstType: Function) => any;
        var is: (obj: any, dstType: Function) => boolean;
        var cast: (obj: any, dstType: Function) => any;
        var ncast: (x: number, t: Function, uncheck: boolean) => number;
        var delegate: (method: Function, target: any) => Function;
        var toString: (o: any) => string;
        var getTypeFromInst: (instance: any) => System.Type;
        var retype: (obj: any, typeFunc: Function) => void;
        var typeOf: (typeFunc: Function) => System.Type;
        var mdi: (array: Array<any>) => int;
        var boxEnum: (enumType: Function, value: number) => System.Enum;
        var check: (x: number, t: Function) => number;
        var toInt8: (x: number) => number;
        var toInt16: (x: number) => number;
        var toUInt32: (x: number) => number;
        var toInt64: (x: number) => number;
        var toUInt64: (x: number) => number;
        var signEx: (e: System.Exception, offset: int) => System.Exception;
        var nv: (n: any) => any;
        var ncl: (a: any, b: any) => any;
        var nle: (a: number, b: number) => boolean;
        var nge: (a: number, b: number) => boolean;
        var nlt: (a: number, b: number) => boolean;
        var ngt: (a: number, b: number) => boolean;
        var nsub: (a: number, b: number) => number;
        var nadd: (a: number, b: number) => number;
        var nmod: (a: number, b: number) => number;
        var ndiv: (a: number, b: number) => number;
        var ndivf: (a: number, b: number) => number;
        var nmul: (a: number, b: number) => number;
        var nband: (a: number, b: number) => number;
        var nbor: (a: number, b: number) => number;
        var nbxor: (a: number, b: number) => number;
        var nshl: (a: number, b: number) => number;
        var nshr: (a: number, b: number) => number;
        var nand: (a: boolean, b: boolean) => boolean;
        var nor: (a: boolean, b: boolean) => boolean;
        var nnot: (a: boolean) => boolean;
        var nneg: (a: number) => number;
        var npos: (a: number) => number;
        var ncpl: (a: number) => number;
        var nlu: (op: Function, a: any) => any;
        var nlb: (op: Function, a: any, b: any) => any;
        var neq: (op: Function, a: any, b: any) => boolean;
        var nne: (op: Function, a: any, b: any) => boolean;
    }
}
