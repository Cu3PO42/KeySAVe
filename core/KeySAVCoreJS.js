//
// KeySAVCoreJS, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
//
// Generated by DuoCode Compiler 1.0.1355.0 [Trial]
//
(function KeySAVCoreJS() {
"use strict";
var $asm = {
    fullName: "KeySAVCoreJS",
    anonymousTypes: [],
    types: [],
    $getAttrs: function() { return [new System.Reflection.AssemblyTitleAttribute.ctor("ClassLibrary"), new System.Reflection.AssemblyDescriptionAttribute.ctor(""), new System.Reflection.AssemblyConfigurationAttribute.ctor(""), new System.Reflection.AssemblyCompanyAttribute.ctor(""), new System.Reflection.AssemblyProductAttribute.ctor("ClassLibrary"), new System.Reflection.AssemblyCopyrightAttribute.ctor("Copyright \xA9  2015"), new System.Reflection.AssemblyTrademarkAttribute.ctor(""), new System.Reflection.AssemblyCultureAttribute.ctor(""), new System.Reflection.AssemblyVersionAttribute.ctor("1.0.0.0"), new System.Reflection.AssemblyFileVersionAttribute.ctor("1.0.0.0"), new DuoCode.Runtime.CompilerAttribute.ctor("1.0.1355.0")]; }
};
var $g = (typeof(global) !== "undefined" ? global : window);
var KeySAVCore = $g.KeySAVCore = $g.KeySAVCore || {};
KeySAVCore.Exceptions = KeySAVCore.Exceptions || {};
KeySAVCore.Structures = KeySAVCore.Structures || {};
var $d = DuoCode.Runtime;
$d.$assemblies["KeySAVCoreJS"] = $asm;
KeySAVCore.BattleVideoBreaker = $d.declare("KeySAVCore.BattleVideoBreaker", System.Object, 0, $asm, function($t, $p) {
    $t.Break = function BattleVideoBreaker_Break(video1, video2, result) {
        var ezeros = KeySAVCore.Structures.PKX.encrypt($d.array(System.Byte, 260));
        var xorstream = $d.array(System.Byte, 1560 /* 260 * 6 */);
        var breakstream = $d.array(System.Byte, 1560 /* 260 * 6 */);
        var bvkey = $d.array(System.Byte, 4096);
        result.value = "";

        //#region Old Exploit to ensure that the usage is correct
        // Validity Check to see what all is participating...

        Array.Copy$2(video1, 19992, breakstream, 0, 1560 /* 260 * 6 */);
        // XOR them together at party offset
        for (var i = 0; i < 1560 /* 260 * 6 */; i++) {
            xorstream[i] = ((breakstream[i] ^ video2[i + 19992]) & 0xFF);
        }

        // Retrieve EKX_1's data
        var ekx1 = $d.array(System.Byte, 260);
        for (var i = 0; i < 260; i++) {
            ekx1[i] = ((xorstream[i + 260] ^ ezeros[i]) & 0xFF);
        }
        for (var i = 0; i < 260; i++) {
            xorstream[i] ^= ekx1[i];
        }

        //#endregion
        // If old exploit does not properly decrypt slot1...
        var pkx = KeySAVCore.Structures.PKX.decrypt(ekx1);
        if (!KeySAVCore.Structures.PKX.verifyCHK(pkx)) {
            result.value = "Improperly set up Battle Videos. Please follow directions and try again";
            return null;
        }

        // Start filling up our key...
        //#region Key Filling (bvkey)
        // Copy in the unique CTR encryption data to ID the video...
        Array.Copy$2(video1, 16, bvkey, 0, 16);

        // Copy unlocking data
        var key1 = $d.array(System.Byte, 260);
        Array.Copy$2(video1, 19992, key1, 0, 260);
        KeySAVCore.Utility.xor$3(ekx1, 0, key1, 0, bvkey, 256, 260);
        Array.Copy$2(video1, 20252 /* 0x4E18 + 260 */, bvkey, 516 /* 0x100 + 260 */, 1300 /* 260*5 */); // XORstream from save1 has just keystream.

        // See if Opponent first slot can be decrypted...

        Array.Copy$2(video1, 21560, breakstream, 0, 1560 /* 260 * 6 */);
        // XOR them together at party offset
        for (var i = 0; i < 1560 /* 260 * 6 */; i++) {
            xorstream[i] = ((breakstream[i] ^ video2[i + 21560]) & 0xFF);
        }
        // XOR through the empty data for the encrypted zero data.
        for (var i = 0; i < 1300 /* 260 * 5 */; i++) {
            bvkey[516 /* 0x100 + 260 */ + i] ^= ezeros[i % 260];
        }

        // Retrieve EKX_2's data
        var ekx2 = $d.array(System.Byte, 260);
        for (var i = 0; i < 260; i++) {
            ekx2[i] = ((xorstream[i + 260] ^ ezeros[i]) & 0xFF);
        }
        for (var i = 0; i < 260; i++) {
            xorstream[i] ^= ekx2[i];
        }
        var key2 = $d.array(System.Byte, 260);
        Array.Copy$2(video1, 21560, key2, 0, 260);
        var pkx2 = KeySAVCore.Structures.PKX.decrypt(ekx2);
        if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(ekx2)) && (KeySAVCore.BitConverter.ToUInt16(pkx2, 
            8) != 0)) {
            KeySAVCore.Utility.xor$3(ekx2, 0, key2, 0, bvkey, 2048, 260);
            Array.Copy$2(video1, 21820 /* 0x5438 + 260 */, bvkey, 2308 /* 0x800 + 260 */, 1300 /* 260 * 5 */); // XORstream from save1 has just keystream.

            for (var i = 0; i < 1300 /* 260 * 5 */; i++) {
                bvkey[2308 /* 0x800 + 260 */ + i] ^= ezeros[i % 260];
            }

            result.value = "Can dump from Opponent Data on this key too!" + System.Environment().NewLine;
        }
        //#endregion

        var ot = KeySAVCore.Utility.TrimCString(Unicode16LE.GetString(pkx, 176, 24));
        var tid = KeySAVCore.BitConverter.ToUInt16(pkx, 12);
        var sid = KeySAVCore.BitConverter.ToUInt16(pkx, 14);
        var tsv = (((tid ^ sid) >> 4) & 0xFFFF);
        // Finished, allow dumping of breakstream
        result.value += String.Format("Success!\nYour first Pokemon's TSV: {0}\nOT: {1}\n\nPlease save your keystream.", 
            $d.array(System.Object, [tsv.ToString$1("0000"), ot]));

        return bvkey;
    };
});
KeySAVCore.BattleVideoReader = $d.declare("KeySAVCore.BattleVideoReader", System.Object, 0, $asm, function($t, $p) {
    $t.cctor = function() {
        $t.offset = 19992;
        $t.keyoff = 256;
    };
    $t.$ator = function() {
        this.video = null;
        this.key = null;
    };
    $t.ctor = function BattleVideoReader(file, key_) {
        $t.$baseType.ctor.call(this);
        this.video = file;
        this.key = key_;
    };
    $t.ctor.prototype = $p;
    $p.getPkx = function BattleVideoReader_getPkx(slot, opponent) {
        var ekx;
        var pkx;
        ekx = KeySAVCore.Utility.xor$2(this.video, $d.toUInt32((19992 /* BattleVideoReader.offset */ + 260 * slot + opponent * 620)), 
            this.key, $d.toUInt32((256 /* BattleVideoReader.keyoff */ + 260 * slot + opponent * 1792)), 
            260);
        pkx = KeySAVCore.Structures.PKX.decrypt(ekx);
        return new KeySAVCore.Structures.PKX.ctor$1(KeySAVCore.Structures.PKX.verifyCHK(pkx) ? pkx : ekx, 
            -1, slot, false);
    };
    $p.get_DumpsEnemy = function BattleVideoReader_get_DumpsEnemy() {
        return (KeySAVCore.BitConverter.ToUInt32(this.key, 2048) | KeySAVCore.BitConverter.ToUInt32(this.key, 
            2052)) != 0;
    };
});
KeySAVCore.BitConverter = $d.declare("KeySAVCore.BitConverter", System.Object, 0, $asm, function($t, $p) {
    $t.ctor = function BitConverter() {
        $t.$baseType.ctor.call(this);
    };
    $t.ctor.prototype = $p;
    $t.ToUInt16$1 = function BitConverter_ToUInt16(array, pos) {
        return ((array[pos] | array[pos + 1] << 8) & 0xFFFF);
    };
    $t.ToUInt16 = function BitConverter_ToUInt16(array, pos) {
        return $t.ToUInt16$1(array, pos);
    };
    $t.ToUInt32 = function BitConverter_ToUInt32(arr, pos) {
        return $d.toUInt32((arr[pos] | arr[pos + 1] << 8 | arr[pos + 2] << 16 | arr[pos + 3] << 24));
    };
    $t.ToInt32 = function BitConverter_ToInt32(arr, pos) {
        return arr[pos] | arr[pos + 1] << 8 | arr[pos + 2] << 16 | arr[pos + 3] << 24;
    };
    $t.GetBytes$2 = function BitConverter_GetBytes(val) {
        var res = $d.array(System.Byte, [((val & 255) & 0xFF), ((val >> 8) & 0xFF)]);
        return res;
    };
    $t.GetBytes = function BitConverter_GetBytes(val) {
        var res = $d.array(System.Byte, [((val & 255) & 0xFF), (((val >> 8) & 255) & 0xFF), (((val >> 16) & 255) & 0xFF), 
            (((val >> 24) & 255) & 0xFF)]);
        return res;
    };
    $t.GetBytes$1 = function BitConverter_GetBytes(val) {
        var res = $d.array(System.Byte, [((val & 255) & 0xFF), (((val >> 8) & 255) & 0xFF), (((val >> 16) & 255) & 0xFF), 
            (((val >> 24) & 255) & 0xFF)]);
        return res;
    };
});
KeySAVCore.Convert = $d.declare("KeySAVCore.Convert", System.Object, 0, $asm, function($t, $p) {
    $t.ctor = function Convert() {
        $t.$baseType.ctor.call(this);
    };
    $t.ctor.prototype = $p;
    $t.ToBoolean = function Convert_ToBoolean(val) {
        return val != 0;
    };
});
KeySAVCore.Exceptions.NoKeyException = $d.declare("KeySAVCore.Exceptions.NoKeyException", System.Exception, 0, $asm, function($t, $p) {
    $t.ctor = function NoKeyException() {
        $t.$baseType.ctor.call(this);
    };
    $t.ctor.prototype = $p;
});
KeySAVCore.Exceptions.NoSaveException = $d.declare("KeySAVCore.Exceptions.NoSaveException", System.Exception, 0, $asm, function($t, $p) {
    $t.ctor = function NoSaveException() {
        $t.$baseType.ctor.call(this);
    };
    $t.ctor.prototype = $p;
});
KeySAVCore.Exceptions.NoBattleVideoException = $d.declare("KeySAVCore.Exceptions.NoBattleVideoException", System.Exception, 0, $asm, function($t, $p) {
    $t.ctor = function NoBattleVideoException() {
        $t.$baseType.ctor.call(this);
    };
    $t.ctor.prototype = $p;
});
KeySAVCore.ISaveReader = $d.declare("KeySAVCore.ISaveReader", null, 66, $asm, function($t, $p) {});
KeySAVCore.Structures.PKX = $d.declare("KeySAVCore.Structures.PKX", null, 62, $asm, function($t, $p) {
    $t.ctor = function PKX() {
        this.EC = 0;
        this.PID = 0;
        this.IV32 = 0;
        this.exp = 0;
        this.HP_EV = 0;
        this.ATK_EV = 0;
        this.DEF_EV = 0;
        this.SPA_EV = 0;
        this.SPD_EV = 0;
        this.SPE_EV = 0;
        this.HP_IV = 0;
        this.ATK_IV = 0;
        this.DEF_IV = 0;
        this.SPE_IV = 0;
        this.SPA_IV = 0;
        this.SPD_IV = 0;
        this.cnt_cool = 0;
        this.cnt_beauty = 0;
        this.cnt_cute = 0;
        this.cnt_smart = 0;
        this.cnt_tough = 0;
        this.cnt_sheen = 0;
        this.markings = 0;
        this.hptype = 0;
        this.nicknamestr = null;
        this.notOT = null;
        this.ot = null;
        this.genderstring = null;
        this.PKRS_Strain = 0;
        this.PKRS_Duration = 0;
        this.metlevel = 0;
        this.otgender = 0;
        this.isegg = false;
        this.isnick = false;
        this.isshiny = false;
        this.isghost = false;
        this.feflag = 0;
        this.genderflag = 0;
        this.altforms = 0;
        this.ability = 0;
        this.abilitynum = 0;
        this.nature = 0;
        this.species = 0;
        this.helditem = 0;
        this.TID = 0;
        this.SID = 0;
        this.TSV = 0;
        this.ESV = 0;
        this.move1 = 0;
        this.move2 = 0;
        this.move3 = 0;
        this.move4 = 0;
        this.move1_pp = 0;
        this.move2_pp = 0;
        this.move3_pp = 0;
        this.move4_pp = 0;
        this.move1_ppu = 0;
        this.move2_ppu = 0;
        this.move3_ppu = 0;
        this.move4_ppu = 0;
        this.eggmove1 = 0;
        this.eggmove2 = 0;
        this.eggmove3 = 0;
        this.eggmove4 = 0;
        this.chk = 0;
        this.OTfriendship = 0;
        this.OTaffection = 0;
        this.egg_year = 0;
        this.egg_month = 0;
        this.egg_day = 0;
        this.met_year = 0;
        this.met_month = 0;
        this.met_day = 0;
        this.eggloc = 0;
        this.metloc = 0;
        this.ball = 0;
        this.encountertype = 0;
        this.gamevers = 0;
        this.countryID = 0;
        this.regionID = 0;
        this.dsregID = 0;
        this.otlang = 0;
        this.box = 0;
        this.slot = 0;
    };
    $t.ctor.prototype = $p;
    $t.ctor$1 = function PKX(pkx, box, slot, isghost) {
        this.box = box;
        this.slot = slot;

        this.isghost = isghost;

        this.nicknamestr = "";
        this.notOT = "";
        this.ot = "";
        this.EC = KeySAVCore.BitConverter.ToUInt32(pkx, 0);
        this.chk = KeySAVCore.BitConverter.ToUInt16(pkx, 6);
        this.species = KeySAVCore.BitConverter.ToUInt16(pkx, 8);
        this.helditem = KeySAVCore.BitConverter.ToUInt16(pkx, 10);
        this.TID = KeySAVCore.BitConverter.ToUInt16(pkx, 12);
        this.SID = KeySAVCore.BitConverter.ToUInt16(pkx, 14);
        this.exp = KeySAVCore.BitConverter.ToUInt32(pkx, 16);
        this.ability = pkx[20];
        this.abilitynum = pkx[21];
        // 0x16, 0x17 - unknown
        this.PID = KeySAVCore.BitConverter.ToUInt32(pkx, 24);
        this.nature = pkx[28];
        this.feflag = ((pkx[29] % 2) & 0xFFFF);
        this.genderflag = (((pkx[29] >> 1) & 3) & 0xFFFF);
        this.altforms = ((pkx[29] >> 3) & 0xFFFF);
        this.HP_EV = pkx[30];
        this.ATK_EV = pkx[31];
        this.DEF_EV = pkx[32];
        this.SPA_EV = pkx[34];
        this.SPD_EV = pkx[35];
        this.SPE_EV = pkx[33];
        this.cnt_cool = pkx[36];
        this.cnt_beauty = pkx[37];
        this.cnt_cute = pkx[38];
        this.cnt_smart = pkx[39];
        this.cnt_tough = pkx[40];
        this.cnt_sheen = pkx[41];
        this.markings = pkx[42];
        this.PKRS_Strain = pkx[43] >> 4;
        this.PKRS_Duration = pkx[43] % 16;

        // Block B
        this.nicknamestr = KeySAVCore.Utility.TrimCString(Unicode16LE.GetString(pkx, 64, 24));
        // 0x58, 0x59 - unused
        this.move1 = KeySAVCore.BitConverter.ToUInt16(pkx, 90);
        this.move2 = KeySAVCore.BitConverter.ToUInt16(pkx, 92);
        this.move3 = KeySAVCore.BitConverter.ToUInt16(pkx, 94);
        this.move4 = KeySAVCore.BitConverter.ToUInt16(pkx, 96);
        this.move1_pp = pkx[98];
        this.move2_pp = pkx[99];
        this.move3_pp = pkx[100];
        this.move4_pp = pkx[101];
        this.move1_ppu = pkx[102];
        this.move2_ppu = pkx[103];
        this.move3_ppu = pkx[104];
        this.move4_ppu = pkx[105];
        this.eggmove1 = KeySAVCore.BitConverter.ToUInt16(pkx, 106);
        this.eggmove2 = KeySAVCore.BitConverter.ToUInt16(pkx, 108);
        this.eggmove3 = KeySAVCore.BitConverter.ToUInt16(pkx, 110);
        this.eggmove4 = KeySAVCore.BitConverter.ToUInt16(pkx, 112);

        // 0x72 - Super Training Flag - Passed with pkx to new form

        // 0x73 - unused/unknown
        this.IV32 = KeySAVCore.BitConverter.ToUInt32(pkx, 116);
        this.HP_IV = this.IV32 & 31;
        this.ATK_IV = (this.IV32 >> 5) & 31;
        this.DEF_IV = (this.IV32 >> 10) & 31;
        this.SPE_IV = (this.IV32 >> 15) & 31;
        this.SPA_IV = (this.IV32 >> 20) & 31;
        this.SPD_IV = (this.IV32 >> 25) & 31;
        this.isegg = ((this.IV32 >> 30) & 1) != 0;
        this.isnick = (this.IV32 >> 31) != 0;

        // Block C
        this.notOT = KeySAVCore.Utility.TrimCString(Unicode16LE.GetString(pkx, 120, 24));
        var notOTG = (pkx[146]) != 0;
        // Memory Editor edits everything else with pkx in a new form

        // Block D
        this.ot = KeySAVCore.Utility.TrimCString(Unicode16LE.GetString(pkx, 176, 24));
        // 0xC8, 0xC9 - unused
        this.OTfriendship = pkx[202];
        this.OTaffection = pkx[203]; // Handled by Memory Editor
        // 0xCC, 0xCD, 0xCE, 0xCF, 0xD0
        this.egg_year = pkx[209];
        this.egg_month = pkx[210];
        this.egg_day = pkx[211];
        this.met_year = pkx[212];
        this.met_month = pkx[213];
        this.met_day = pkx[214];
        // 0xD7 - unused
        this.eggloc = KeySAVCore.BitConverter.ToUInt16(pkx, 216);
        this.metloc = KeySAVCore.BitConverter.ToUInt16(pkx, 218);
        this.ball = pkx[220];
        this.metlevel = pkx[221] & 127;
        this.otgender = (pkx[221]) >> 7;
        this.encountertype = pkx[222];
        this.gamevers = pkx[223];
        this.countryID = pkx[224];
        this.regionID = pkx[225];
        this.dsregID = pkx[226];
        this.otlang = pkx[227];

        if (this.genderflag == 0)
            this.genderstring = "\u2642";
        else
            if (this.genderflag == 1)
                this.genderstring = "\u2640";
            else
                this.genderstring = "-";

        this.hptype = ((15 * ((this.HP_IV & 1) + 2 * (this.ATK_IV & 1) + 4 * (this.DEF_IV & 1) + 8 * (this.SPE_IV & 1) + 16 * (this.SPA_IV & 1) + 32 * (this.SPD_IV & 1))) / 63 | 0) + 1;

        this.TSV = (((this.TID ^ this.SID) >> 4) & 0xFFFF);
        this.ESV = ((((this.PID >> 16) ^ (this.PID & 65535)) >> 4) & 0xFFFF);

        this.isshiny = (this.TSV == this.ESV);
    };
    $t.ctor$1.prototype = $p;
    $t.shuffleArray = function PKX_shuffleArray(pkx, sv) {
        var ekx = $d.array(System.Byte, pkx.length);
        Array.Copy(pkx, ekx, 8);

        // Now to shuffle the blocks

        // Define Shuffle Order Structure
        var aloc = $d.array(System.Byte, [0, 0, 0, 0, 0, 0, 1, 1, 2, 3, 2, 3, 1, 1, 2, 3, 2, 3, 1, 1, 
            2, 3, 2, 3]);
        var bloc = $d.array(System.Byte, [1, 1, 2, 3, 2, 3, 0, 0, 0, 0, 0, 0, 2, 3, 1, 1, 3, 2, 2, 3, 
            1, 1, 3, 2]);
        var cloc = $d.array(System.Byte, [2, 3, 1, 1, 3, 2, 2, 3, 1, 1, 3, 2, 0, 0, 0, 0, 0, 0, 3, 2, 
            3, 2, 1, 1]);
        var dloc = $d.array(System.Byte, [3, 2, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 0, 0, 
            0, 0, 0, 0]);

        // Get Shuffle Order
        var shlog = $d.array(System.Byte, [aloc[sv], bloc[sv], cloc[sv], dloc[sv]]);

        // UnShuffle Away!
        for (var b = 0; b < 4; b++) {
            Array.Copy$2(pkx, 8 + 56 * shlog[b], ekx, 8 + 56 * b, 56);
        }

        // Fill the Battle Stats back
        if (pkx.length > 232)
            Array.Copy$2(pkx, 232, ekx, 232, 28);
        return ekx;
    };
    $t.decrypt = function PKX_decrypt(ekx) {
        var pkx = $d.array(System.Byte, 232);
        Array.Copy(ekx, pkx, 232);
        var pv = KeySAVCore.BitConverter.ToUInt32(pkx, 0);
        var sv = (((pv & 253952) >> 13) % 24);

        var seed = pv;

        // Decrypt Blocks with RNG Seed
        for (var i = 8; i < 232; i += 2) {
            var pre = pkx[i] + ((pkx[i + 1]) << 8);
            seed = LCRNG.next(seed);
            var seedxor = (((seed) >> 16) | 0);
            var post = (pre ^ seedxor);
            pkx[i] = (((post) & 255) & 0xFF);
            pkx[i + 1] = ((((post) >> 8) & 255) & 0xFF);
        }

        // Deshuffle
        pkx = $t.shuffleArray(pkx, sv);
        return pkx;
    };
    $t.encrypt = function PKX_encrypt(pkx) {
        // Shuffle
        var pv = KeySAVCore.BitConverter.ToUInt32(pkx, 0);
        var sv = (((pv & 253952) >> 13) % 24);

        var ekxdata = $d.array(System.Byte, pkx.length);
        Array.Copy(pkx, ekxdata, pkx.length);

        // If I unshuffle 11 times, the 12th (decryption) will always decrypt to ABCD.
        // 2 x 3 x 4 = 12 (possible unshuffle loops -> total iterations)
        for (var i = 0; i < 11; i++) {
            ekxdata = $t.shuffleArray(ekxdata, sv);
        }

        var seed = pv;
        // Encrypt Blocks with RNG Seed
        for (var i = 8; i < 232; i += 2) {
            var pre = ekxdata[i] + ((ekxdata[i + 1]) << 8);
            seed = LCRNG.next(seed);
            var seedxor = (((seed) >> 16) | 0);
            var post = (pre ^ seedxor);
            ekxdata[i] = (((post) & 255) & 0xFF);
            ekxdata[i + 1] = ((((post) >> 8) & 255) & 0xFF);
        }

        // Encrypt the Party Stats
        seed = pv;
        if (pkx.length > 232)
            for (var i = 232; i < 260; i += 2) {
                var pre = ekxdata[i] + ((ekxdata[i + 1]) << 8);
                seed = LCRNG.next(seed);
                var seedxor = (((seed) >> 16) | 0);
                var post = (pre ^ seedxor);
                ekxdata[i] = (((post) & 255) & 0xFF);
                ekxdata[i + 1] = ((((post) >> 8) & 255) & 0xFF);
            }

        // Done
        return ekxdata;
    };
    $t.verifyCHK = function PKX_verifyCHK(pkx) {
        var chk = 0;
        for (var i = 8; i < 232; i += 2) {
            chk += KeySAVCore.BitConverter.ToUInt16(pkx, i);
        }

        var actualsum = KeySAVCore.BitConverter.ToUInt16(pkx, 6);
        if ((KeySAVCore.BitConverter.ToUInt16(pkx, 8) > 750) || (KeySAVCore.BitConverter.ToUInt16(pkx, 
            144) != 0))
            return false;
        return ((chk & 65535) == actualsum);
    };
    $t.getDloc = function PKX_getDloc(ec) {
        // Define Shuffle Order Structure
        var dloc = $d.array(System.Byte, [3, 2, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 0, 0, 
            0, 0, 0, 0]);
        var sv = (((ec & 253952) >> 13) % 24);

        return dloc[sv];
    };
});
KeySAVCore.SaveBreaker = $d.declare("KeySAVCore.SaveBreaker", System.Object, 0, $asm, function($t, $p) {
    $t.cctor = function() {
        $t.Magic = 1111835974;
        $t.eggnames = null;
        $t.eggnames = $d.array(String, ["\u30BF\u30DE\u30B4", "Egg", "\u0152uf", "Uovo", "Ei", "", "Huevo", 
            "\uC54C"]);
    };
    $t.Load = function SaveBreaker_Load(input, keyGetter) {
        if (input.length == 1048576)
            return new KeySAVCore.SaveReaderEncrypted.ctor$1(input, keyGetter);
        if (input.length == 483328 && KeySAVCore.BitConverter.ToUInt32(input, 482832) == 1111835974 /* SaveBreaker.Magic */)
            return new KeySAVCore.SaveReaderDecrypted.ctor(input, "ORAS");
        if (input.length == 415232 && KeySAVCore.BitConverter.ToUInt32(input, 414736) == 1111835974 /* SaveBreaker.Magic */)
            return new KeySAVCore.SaveReaderDecrypted.ctor(input, "XY");
        if (input.length == 222720 /* 232 * 30 * 32 */)
            return new KeySAVCore.SaveReaderDecrypted.ctor(input, "RAW");
        throw new KeySAVCore.Exceptions.NoSaveException.ctor();
    };
    $t.Break = function SaveBreaker_Break(break1, break2, result, respkx) {
        var offset = $d.array(System.Int32, 2);
        var empty = $d.array(System.Byte, 232);
        var emptyekx = { value: $d.array(System.Byte, 232) };
        var pkx = $d.array(System.Byte, 232);
        var savkey;
        var save1Save;
        savkey = $d.array(System.Byte, 740052);

        result.value = "";

        if (!KeySAVCore.Utility.SequenceEqual$1(break1, 16, break2, 16, 8)) {
            result.value = "Saves are not from the same game!\nPlease follow the instructions.";
            respkx.value = $d.array(System.Byte, 232);
            return null;
        }

        // TODO readd upgrade logic
        if (KeySAVCore.Utility.SequenceEqual$1(break1, 524288, break2, 524288, 520192)) {
            save1Save = break2;
            for (var i = 162304; i < 446160; ++i) {
                break2[i + 520192] = ((break2[i] ^ break1[i] ^ break1[i + 520192]) & 0xFF);
            }
        }
        else
            if (KeySAVCore.Utility.SequenceEqual$1(break1, 4096, break2, 4096, 520192)) {
                save1Save = break1;
            }
            else {
                result.value = "The saves are seperated by more than one save.\nPlease follow the instructions.";
                respkx.value = $d.array(System.Byte, 232);
                return null;
            }

        (function() {
            var $ref = { value: break1 };
            var $ref1 = { value: break2 };
            var $result$ = KeySAVCore.Utility.Switch($d.arrayType(System.Byte), $ref, $ref1);
            break1 = $ref.value;
            break2 = $ref1.value;
            return $result$;
        }).call(this);

        //#region Finding the User Specific Data: Using Valid to keep track of progress...
        // Do Break. Let's first do some sanity checking to find out the 2 offsets we're dumping from.
        // Loop through save file to find
        var fo = 682496; // Initial Offset, can tweak later.
        var success = 0;

        for (var d = 0; d < 2; d++) {
            // Do this twice to get both box offsets.
            for (var i = fo; i <= 757552; i += 68096) {
                var err = 0;
                // Start at findoffset and see if it matches pattern
                if ((break1[i + 4] == break2[i + 4]) && (break1[i + 4 + 232] == break2[i + 4 + 232])) {
                    // Sanity Placeholders are the same
                    for (var j = 0; j < 4; j++) {
                        if (break1[i + j] == break2[i + j])
                            err++;
                    }

                    if (err < 4) {
                        // Keystream ^ PID doesn't match entirely. Keep checking.
                        for (var j = 8; j < 232; j++) {
                            if (break1[i + j] == break2[i + j])
                                err++;
                        }

                        if (err < 20) {
                            // Tolerable amount of difference between offsets. We have a result.
                            offset[d] = i;
                            break;
                        }
                    }
                }
            }
            fo = offset[d] + 6960 /* 232 * 30 */; // Fast forward out of this box to find the next.
        }

        // Now that we have our two box offsets...
        // Check to see if we actually have them.

        if ((offset[0] == 0) || (offset[1] == 0)) {
            // We have a problem. Don't continue.
            result.value = "Unable to Find Box.\n";
        }
        else {
            // Let's go deeper. We have the two box offsets.
            // Chunk up the base streams.
            var estream1 = $d.array(System.Byte, 30 * 232, [30, 232]);
            var estream2 = $d.array(System.Byte, 30 * 232, [30, 232]);
            // Stuff 'em.
            for (var i = 0; i < 30; i++) {
                for (var j = 0; j < 232; j++) {
                    estream1[(i) * estream1.$ranks[1] + (j)] = break1[offset[0] + 232 * i + j];
                    estream2[(i) * estream2.$ranks[1] + (j)] = break2[offset[1] + 232 * i + j];
                }
            }

            // Okay, now that we have the encrypted streams, formulate our EKX.
            var nick = $t().eggnames[1];
            // Stuff in the nickname to our blank EKX.
            var nicknamebytes = { value: Unicode16LE.GetBytes(nick) };
            Array.Resize(System.Byte, nicknamebytes, 24);
            Array.Copy$2(nicknamebytes.value, 0, empty, 64, nicknamebytes.value.length);

            // Encrypt the Empty PKX to EKX.
            Array.Copy(empty, emptyekx.value, 232);
            emptyekx.value = KeySAVCore.Structures.PKX.decrypt(emptyekx.value);
            // Not gonna bother with the checksum, as this empty file is temporary.

            // Sweet. Now we just have to find the E0-E3 values. Let's get our polluted streams from each.
            // Save file 1 has empty box 1. Save file 2 has empty box 2.
            var pstream1 = $d.array(System.Byte, 30 * 232, [30, 232]); // Polluted Keystream 1
            var pstream2 = $d.array(System.Byte, 30 * 232, [30, 232]); // Polluted Keystream 2
            for (var i = 0; i < 30; i++) {
                for (var j = 0; j < 232; j++) {
                    pstream1[(i) * pstream1.$ranks[1] + (j)] = ((estream1[(i) * estream1.$ranks[1] + (j)] ^ emptyekx.value[j]) & 0xFF);
                    pstream2[(i) * pstream2.$ranks[1] + (j)] = ((estream2[(i) * estream2.$ranks[1] + (j)] ^ emptyekx.value[j]) & 0xFF);
                }
            }

            // Cool. So we have a fairly decent keystream to roll with. We now need to find what the E0-E3 region is.
            // 0x00000000 Encryption Constant has the D block last. 
            // We need to make sure our Supplied Encryption Constant Pokemon have the D block somewhere else (Pref in 1 or 3).

            // First, let's get out our polluted EKX's.
            var polekx = $d.array(System.Byte, 6 * 232, [6, 232]);
            for (var i = 0; i < 6; i++) {
                for (var j = 0; j < 232; j++) {
                    polekx[(i) * polekx.$ranks[1] + (j)] = ((break1[offset[1] + 232 * i + j] ^ pstream2[(i) * pstream2.$ranks[1] + (j)]) & 0xFF);
                }
            }

            var encryptionconstants = $d.array(System.UInt32, 6); // Array for all 6 Encryption Constants. 
            var valid = 0;
            for (var i = 0; i < 6; i++) {
                encryptionconstants[i] = polekx[(i) * polekx.$ranks[1] + 0];
                encryptionconstants[i] += polekx[(i) * polekx.$ranks[1] + 1] * 256;
                encryptionconstants[i] += polekx[(i) * polekx.$ranks[1] + 2] * 65536;
                encryptionconstants[i] += polekx[(i) * polekx.$ranks[1] + 3] * 16777216;
                // EC Obtained. Check to see if Block D is not last.
                if (KeySAVCore.Structures.PKX.getDloc(encryptionconstants[i]) != 3) {
                    valid++;
                    // Find the Origin/Region data.
                    var encryptedekx = $d.array(System.Byte, 232);
                    var decryptedpkx = $d.array(System.Byte, 232);
                    for (var z = 0; z < 232; z++) {
                        encryptedekx[z] = polekx[(i) * polekx.$ranks[1] + (z)];
                    }

                    decryptedpkx = KeySAVCore.Structures.PKX.decrypt(encryptedekx);

                    // finalize data

                    // Okay, now that we have the encrypted streams, formulate our EKX.
                    nick = $t().eggnames[decryptedpkx[227] - 1];
                    // Stuff in the nickname to our blank EKX.
                    nicknamebytes.value = Unicode16LE.GetBytes(nick);
                    Array.Resize(System.Byte, nicknamebytes, 24);
                    Array.Copy$2(nicknamebytes.value, 0, empty, 64, nicknamebytes.value.length);

                    // Dump it into our Blank EKX. We have won!
                    empty[224] = decryptedpkx[224];
                    empty[225] = decryptedpkx[225];
                    empty[226] = decryptedpkx[226];
                    empty[227] = decryptedpkx[227];
                    break;
                }
            }
            //#endregion

            if (valid == 0) // We didn't get any valid EC's where D was not in last. Tell the user to try again with different specimens.
                result.value = "The 6 supplied Pokemon are not suitable. \nRip new saves with 6 different ones that originated from your save file.\n";
            else {
                //#region Fix up our Empty File
                // We can continue to get our actual keystream.
                // Let's calculate the actual checksum of our empty pkx.
                var chk = 0;
                for (var i = 8; i < 232; i += 2) {
                    chk += KeySAVCore.BitConverter.ToUInt16(empty, i);
                }

                // Apply New Checksum
                Array.Copy$2(KeySAVCore.BitConverter.GetBytes$1(chk), 0, empty, 6, 2);

                // Okay. So we're now fixed with the proper blank PKX. Encrypt it!
                Array.Copy(empty, emptyekx.value, 232);
                emptyekx.value = KeySAVCore.Structures.PKX.encrypt(emptyekx.value);
                Array.Resize(System.Byte, emptyekx, 232); // ensure it's 232 bytes.

                // Copy over 0x10-0x1F (Save Encryption Unused Data so we can track data).
                Array.Copy$2(break1, 16, savkey, 0, 8);
                // Include empty data
                savkey[16] = empty[224];
                savkey[17] = empty[225];
                savkey[18] = empty[226];
                savkey[19] = empty[227];
                // Copy over the scan offsets.
                Array.Copy$2(KeySAVCore.BitConverter.GetBytes(offset[0]), 0, savkey, 28, 4);

                for (var i = 0; i < 30; i++) {
                    for (var j = 0; j < 232; j++) {
                        savkey[256 + i * 232 + j] = ((estream1[(i) * estream1.$ranks[1] + (j)] ^ emptyekx.value[j]) & 0xFF);
                        savkey[7216 /* 0x100 + (30 * 232) */ + i * 232 + j] = ((estream2[(i) * estream2.$ranks[1] + (j)] ^ emptyekx.value[j]) & 0xFF);
                    }
                }
                //#endregion
                // Let's extract some of the information now for when we set the Keystream filename.
                //#region Keystream Naming
                var data1 = $d.array(System.Byte, 232);
                var data2 = $d.array(System.Byte, 232);
                for (var i = 0; i < 232; i++) {
                    data1[i] = ((savkey[256 + i] ^ break1[offset[0] + i]) & 0xFF);
                    data2[i] = ((savkey[256 + i] ^ break2[offset[0] + i]) & 0xFF);
                }
                var data1a = $d.array(System.Byte, 232);
                var data2a = $d.array(System.Byte, 232);
                Array.Copy(data1, data1a, 232);
                Array.Copy(data2, data2a, 232);
                var pkx1 = KeySAVCore.Structures.PKX.decrypt(data1);
                var pkx2 = KeySAVCore.Structures.PKX.decrypt(data2);
                var chk1 = 0;
                var chk2 = 0;
                for (var i = 8; i < 232; i += 2) {
                    chk1 += KeySAVCore.BitConverter.ToUInt16(pkx1, i);
                    chk2 += KeySAVCore.BitConverter.ToUInt16(pkx2, i);
                }
                if (KeySAVCore.Structures.PKX.verifyCHK(pkx1) && KeySAVCore.Convert.ToBoolean(KeySAVCore.BitConverter.ToUInt16(pkx1, 
                    8))) {
                    // Save 1 has the box1 data
                    pkx = pkx1;
                    success = 1;
                }
                else
                    if (KeySAVCore.Structures.PKX.verifyCHK(pkx2) && KeySAVCore.Convert.ToBoolean(KeySAVCore.BitConverter.ToUInt16(pkx2, 
                        8))) {
                        // Save 2 has the box1 data
                        pkx = pkx2;
                        success = 1;
                    }
                    else {
                        // Data isn't decrypting right...
                        for (var i = 0; i < 232; i++) {
                            data1a[i] ^= empty[i];
                            data2a[i] ^= empty[i];
                        }
                        pkx1 = KeySAVCore.Structures.PKX.decrypt(data1a);
                        pkx2 = KeySAVCore.Structures.PKX.decrypt(data2a);
                        if (KeySAVCore.Structures.PKX.verifyCHK(pkx1) && KeySAVCore.Convert.ToBoolean(KeySAVCore.BitConverter.ToUInt16(pkx1, 
                            8))) {
                            // Save 1 has the box1 data
                            pkx = pkx1;
                            success = 1;
                        }
                        else
                            if (KeySAVCore.Structures.PKX.verifyCHK(pkx2) && KeySAVCore.Convert.ToBoolean(KeySAVCore.BitConverter.ToUInt16(pkx2, 
                                8))) {
                                // Save 2 has the box1 data
                                pkx = pkx2;
                                success = 1;
                            }
                            else {}
                    }
                //#endregion
            }
        }

        if (success == 1) {
            // Clear the keystream file...
            Array.Clear(savkey, 256, 215760 /* 232*30*31 */);
            Array.Clear(savkey, 262144, 215760 /* 232*30*31 */);

            // Copy the key for the slot selector
            Array.Copy$2(save1Save, 360, savkey, 524288, 4);

            // Copy the key for the other save slot
            KeySAVCore.Utility.xor$3(break2, $d.toUInt32(offset[0]), break2, $d.toUInt32((offset[0] - 520192)), 
                savkey, 524292, 215760 /* 232*30*31 */);

            // Since we don't know if the user put them in in the wrong order, let's just markup our keystream with data.
            var data1 = $d.array(System.Byte, 232);
            var data2 = $d.array(System.Byte, 232);
            for (var i = 0; i < 31; i++) {
                for (var j = 0; j < 30; j++) {
                    Array.Copy$2(break1, offset[0] + i * 6960 /* 232 * 30 */ + j * 232, data1, 0, 232);
                    Array.Copy$2(break2, offset[0] + i * 6960 /* 232 * 30 */ + j * 232, data2, 0, 232);
                    if (System.Linq.Enumerable.SequenceEqual(System.Byte, data1, data2)) {
                        // Just copy data1 into the key file.
                        Array.Copy$2(data1, 0, savkey, 256 + i * 6960 /* 232 * 30 */ + j * 232, 232);
                    }
                    else {
                        // Copy both datas into their keystream spots.
                        Array.Copy$2(data1, 0, savkey, 256 + i * 6960 /* 232 * 30 */ + j * 232, 232);
                        Array.Copy$2(data2, 0, savkey, 262144 + i * 6960 /* 232 * 30 */ + j * 232, 232);
                    }
                }
            }

            // Save file diff is done, now we're essentially done. Save the keystream.

            // Success
            result.value = "Keystreams were successfully bruteforced!\n\n";
            result.value += "Save your keystream now...";
            respkx.value = pkx;
            var tmp = new KeySAVCore.Structures.SaveKey.ctor$1(savkey);
            return tmp;
        }
        else
            result.value += "Keystreams were NOT bruteforced!\n\nStart over and try again :(";
        respkx.value = null;
        return null;
    };
});
KeySAVCore.Structures.SaveKey = $d.declare("KeySAVCore.Structures.SaveKey", null, 62, $asm, function($t, $p) {
    $t.ctor = function SaveKey() {
        this.stamp1 = 0;
        this.stamp2 = 0;
        this.magic = 0;
        this.location = null;
        this.boxOffset = 0;
        this.boxKey1 = null;
        this.blank = null;
        this.slotsUnlocked = null;
        this.boxKey2 = null;
        this.slot1Flag = 0;
        this.slot1Key = null;
    };
    $t.ctor.prototype = $p;
    $t.ctor$1 = function SaveKey(key) {
        this.stamp1 = KeySAVCore.BitConverter.ToUInt32(key, 0);
        this.stamp2 = KeySAVCore.BitConverter.ToUInt32(key, 4);
        this.magic = KeySAVCore.BitConverter.ToUInt32(key, 8);
        this.location = $d.array(System.Byte, 4);
        Array.Copy$2(key, 16, this.location, 0, 4);
        this.boxOffset = KeySAVCore.BitConverter.ToUInt32(key, 28);
        this.boxKey1 = $d.array(System.Byte, 215760);
        Array.Copy$2(key, 256, this.boxKey1, 0, 215760);
        this.blank = $d.array(System.Byte, 232);
        Array.Copy$2(key, 216016, this.blank, 0, 232);
        this.slotsUnlocked = $d.array(Boolean, 930);
        Array.Copy$2(key, 216248, this.slotsUnlocked, 0, 930);
        this.boxKey2 = $d.array(System.Byte, 215760);
        Array.Copy$2(key, 262144, this.boxKey2, 0, 215760);
        this.slot1Flag = KeySAVCore.BitConverter.ToUInt32(key, 524288);
        this.slot1Key = $d.array(System.Byte, 215760);
        Array.Copy$2(key, 524292, this.slot1Key, 0, 215760);
        if (this.magic != 1111835974) {
            this.magic = 1111835974;
            this.blank = $d.array(System.Byte, 232);
            Array.Copy$2(this.location, 0, this.blank, 224, 4);
            var nicknamebytes = Unicode16LE.GetBytes(KeySAVCore.SaveBreaker().eggnames[this.blank[227] - 1]);
            Array.Copy$2(nicknamebytes, 0, this.blank, 64, nicknamebytes.length > 24 ? 24 : nicknamebytes.length);

            var chk = 0;
            for (var i = 8; i < 232; i += 2) {
                chk += KeySAVCore.BitConverter.ToUInt16(this.blank, i);
            }

            Array.Copy$2(KeySAVCore.BitConverter.GetBytes$1(chk), 0, this.blank, 6, 2);
            this.blank = KeySAVCore.Structures.PKX.encrypt(this.blank);

            for (var i = 0; i < 930; ++i) {
                this.slotsUnlocked[i] = KeySAVCore.Utility.Empty$1(this.boxKey1, i * 232, 232);
            }
        }
    };
    $t.ctor$1.prototype = $p;
    $p.Export = function SaveKey_Export() {
        var res = $d.array(System.Byte, 740052);
        Array.Copy$2(KeySAVCore.BitConverter.GetBytes$1(this.stamp1), 0, res, 0, 4);
        Array.Copy$2(KeySAVCore.BitConverter.GetBytes$1(this.stamp2), 0, res, 4, 4);
        Array.Copy$2(KeySAVCore.BitConverter.GetBytes$1(this.magic), 0, res, 8, 4);
        Array.Copy$2(this.location, 0, res, 16, 4);
        Array.Copy$2(KeySAVCore.BitConverter.GetBytes$1(this.boxOffset), 0, res, 28, 4);
        Array.Copy$2(this.boxKey1, 0, res, 256, 215760);
        Array.Copy$2(this.blank, 0, res, 216016, 232);
        Array.Copy$2(this.slotsUnlocked, 0, res, 216248, 930);
        Array.Copy$2(this.boxKey2, 0, res, 262144, 215760);
        Array.Copy$2(KeySAVCore.BitConverter.GetBytes$1(this.slot1Flag), 0, res, 524288, 4);
        Array.Copy$2(this.slot1Key, 0, res, 524292, 215760);
        return res;
    };
});
KeySAVCore.SaveReaderDecrypted = $d.declare("KeySAVCore.SaveReaderDecrypted", System.Object, 0, $asm, function($t, $p) {
    $t.$intfs = [KeySAVCore.ISaveReader];
    $t.cctor = function() {
        $t.orasOffset = 208896;
        $t.xyOffset = 140800;
    };
    $t.$ator = function() {
        this.sav = null;
        this.offset = 0;
    };
    $p.get_KeyName = function SaveReaderDecrypted_get_KeyName() {
        return "Decrypted. No Key needed";
    };
    $p.get_UnlockedSlots = function SaveReaderDecrypted_get_UnlockedSlots() {
        return 930;
    };
    $t.ctor = function SaveReaderDecrypted(file, type) {
        $t.$baseType.ctor.call(this);
        this.sav = file;
        switch (type) {
            case "XY":
                this.offset = 140800 /* SaveReaderDecrypted.xyOffset */;
                break;
            case "ORAS":
                this.offset = 208896 /* SaveReaderDecrypted.orasOffset */;
                break;
            case "RAW":
                this.offset = 4;
                var ekx = $d.array(System.Byte, 232);
                Array.Copy$2(this.sav, 4, ekx, 0, 232);
                if (!KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(ekx)))
                    this.offset = 8;
                break;
        }
    };
    $t.ctor.prototype = $p;
    $p.scanSlots = function SaveReaderDecrypted_scanSlots() {};
    $p.scanSlots$1 = function SaveReaderDecrypted_scanSlots(pos) {};
    $p.scanSlots$2 = function SaveReaderDecrypted_scanSlots(from, to) {};
    $p.getPkx = function SaveReaderDecrypted_getPkx(pos) {
        var pkx = $d.array(System.Byte, 232);
        var pkxOffset = $d.toUInt32((this.offset + pos * 232));
        if (KeySAVCore.Utility.SequenceEqual$1(pkx, 0, this.sav, pkxOffset, 232))
            return null;
        Array.Copy$3(this.sav, pkxOffset, pkx, 0, 232);
        pkx = KeySAVCore.Structures.PKX.decrypt(pkx);
        if (KeySAVCore.Structures.PKX.verifyCHK(pkx) && (pkx[8] | pkx[9]) != 0) {
            return new KeySAVCore.Structures.PKX.ctor$1(pkx, ((pos / 30 | 0) & 0xFF), ((pos % 30) & 0xFF), 
                false);

        }
        return null;
    };
    $p.KeySAVCore$ISaveReader$get_KeyName = $p.get_KeyName;
    $p.KeySAVCore$ISaveReader$get_UnlockedSlots = $p.get_UnlockedSlots;
    $p.KeySAVCore$ISaveReader$scanSlots$2 = $p.scanSlots$2;
    $p.KeySAVCore$ISaveReader$scanSlots = $p.scanSlots;
    $p.KeySAVCore$ISaveReader$scanSlots$1 = $p.scanSlots$1;
    $p.KeySAVCore$ISaveReader$getPkx = $p.getPkx;
});
KeySAVCore.SaveReaderEncrypted = $d.declare("KeySAVCore.SaveReaderEncrypted", System.Object, 0, $asm, function($t, $p) {
    $t.$intfs = [KeySAVCore.ISaveReader];
    $t.cctor = function() {
        $t.zeros = null;
        $t.ezeros = null;
        $t.zeros = $d.array(System.Byte, 232);
        $t.ezeros = KeySAVCore.Structures.PKX.encrypt($t.zeros);
        (function() {
            var $ref = { value: $t.ezeros };
            var $result$ = Array.Resize(System.Byte, $ref, 232);
            $t.ezeros = $ref.value;
            return $result$;
        }).call(this);
    };
    $t.$ator = function() {
        this.sav = null;
        this.key = new KeySAVCore.Structures.SaveKey.ctor();
        this.activeSlot = 0;
        this._KeyName = null;
    };
    $p.get_KeyName = function SaveReaderEncrypted_get_KeyName() {
        return this._KeyName;
    };
    $p.get_UnlockedSlots = function SaveReaderEncrypted_get_UnlockedSlots() {
        var res = 0;
        for (var $i = 0, $a = this.key.slotsUnlocked, $length = $a.length; $i != $length; $i++) {
            var val = $a[$i];
            if (val)
                ++res;
        }
        return res;
    };
    $t.ctor$1 = function SaveReaderEncrypted(file, keyGetter) {
        $t.$baseType.ctor.call(this);
        this.sav = file;

        this.key = keyGetter(KeySAVCore.BitConverter.ToUInt32(this.sav, 16), KeySAVCore.BitConverter.ToUInt32(this.sav, 
            20));

        this._KeyName = System.IO.Path.GetFileName(this._KeyName);

        if (this.key.slot1Flag == KeySAVCore.BitConverter.ToUInt32(this.sav, 360))
            this.activeSlot = 0;
        else
            this.activeSlot = 1;

        KeySAVCore.Utility.XorInPlace(this.sav, this.key.boxOffset - 520192, this.key.slot1Key, 0, 215760 /* 232*30*31 */);
    };
    $t.ctor$1.prototype = $p;
    $t.ctor$2 = function SaveReaderEncrypted(file, key_) {
        $t.$baseType.ctor.call(this);
        this.sav = file;

        this.key = new KeySAVCore.Structures.SaveKey.ctor$1(key_);

        this._KeyName = System.IO.Path.GetFileName(this._KeyName);

        if (this.key.slot1Flag == KeySAVCore.BitConverter.ToUInt32(this.sav, 360))
            this.activeSlot = 0;
        else
            this.activeSlot = 1;

        KeySAVCore.Utility.XorInPlace(this.sav, this.key.boxOffset - 520192, this.key.slot1Key, 0, 215760 /* 232*30*31 */);
    };
    $t.ctor$2.prototype = $p;
    $t.ctor = function SaveReaderEncrypted(file, key) {
        $t.$baseType.ctor.call(this);
        this.sav = file;

        this.key = key;

        this._KeyName = "";

        if (key.slot1Flag == KeySAVCore.BitConverter.ToUInt32(this.sav, 360))
            this.activeSlot = 0;
        else
            this.activeSlot = 1;

        KeySAVCore.Utility.XorInPlace(this.sav, key.boxOffset - 520192, key.slot1Key, 0, 215760 /* 232*30*31 */);
    };
    $t.ctor.prototype = $p;
    $p.scanSlots = function SaveReaderEncrypted_scanSlots() {
        var ghost = {};
        for (var i = 0; i < 930 /* 30*31 */; ++i) {
            this.getPkxRaw(i, 0, ghost);
            this.getPkxRaw(i, 1, ghost);
        }
    };
    $p.scanSlots$1 = function SaveReaderEncrypted_scanSlots(pos) {
        var ghost = {};
        this.getPkxRaw(pos, 0, ghost);
        this.getPkxRaw(pos, 1, ghost);
    };
    $p.scanSlots$2 = function SaveReaderEncrypted_scanSlots(start, end) {
        for (var i = start; i <= end; ++i) {
            var ghost = {};
            this.getPkxRaw(i, 0, ghost);
            this.getPkxRaw(i, 1, ghost);
        }
    };
    $p.getPkx = function SaveReaderEncrypted_getPkx(pos) {
        var ghost = {};
        var data = this.getPkxRaw(pos, this.activeSlot, ghost);
        if (data == null)
            return null;
        return new KeySAVCore.Structures.PKX.ctor$1(data, ((pos / 30 | 0) & 0xFF), ((pos % 30) & 0xFF), 
            ghost.value);
    };
    $p.getPkxRaw = function SaveReaderEncrypted_getPkxRaw(pos, slot, ghost) {
        // Auto updates the keystream when it dumps important data!
        var ekx = $d.array(System.Byte, 232);

        ghost.value = true;

        var keyOffset = pos * 232;
        var savOffset = $d.toUInt32((keyOffset + this.key.boxOffset - (1 - slot) * 520192));

        if (KeySAVCore.Utility.SequenceEqual($t.zeros, this.key.boxKey1, keyOffset) && KeySAVCore.Utility.SequenceEqual($t.zeros, 
            this.key.boxKey2, keyOffset))
            return null;
        else
            if (KeySAVCore.Utility.SequenceEqual($t.zeros, this.key.boxKey1, keyOffset)) {
                // Key2 is confirmed to dump the data.
                ekx = KeySAVCore.Utility.xor$2(this.key.boxKey2, keyOffset, this.sav, savOffset, 232);
                ghost.value = false;
                this.key.slotsUnlocked[slot] = true;
            }
            else
                if (KeySAVCore.Utility.SequenceEqual($t.zeros, this.key.boxKey2, keyOffset)) {
                    // Haven't dumped from this slot yet.
                    if (KeySAVCore.Utility.SequenceEqual$1(this.key.boxKey1, keyOffset, this.sav, savOffset, 
                        232)) {
                        // Slot hasn't changed.
                        return null;
                    }
                    else {
                        // Try and decrypt the data...
                        ekx = KeySAVCore.Utility.xor$2(this.key.boxKey1, keyOffset, this.sav, savOffset, 
                            232);
                        if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(ekx))) {
                            // Data has been dumped!
                            // Fill keystream data with our log.
                            Array.Copy$3(this.sav, savOffset, this.key.boxKey2, keyOffset, 232);
                        }
                        else {
                            // Try xoring with the empty data.
                            if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                this.key.blank)))) {
                                ekx = KeySAVCore.Utility.xor(ekx, this.key.blank);
                                KeySAVCore.Utility.xor$3(this.key.blank, 0, this.sav, savOffset, this.key.boxKey2, 
                                    keyOffset, 232);
                            }
                            else
                                if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                    $t.ezeros)))) {
                                    ekx = KeySAVCore.Utility.xor(ekx, $t.ezeros);
                                    KeySAVCore.Utility.xor$3($t.ezeros, 0, this.sav, savOffset, this.key.boxKey2, 
                                        keyOffset, 232);
                                }
                                else
                                    return null; // Not a failed decryption; we just haven't seen new data here yet.
                        }
                    }
                }
                else {
                    // We've dumped data at least once.
                    if (KeySAVCore.Utility.SequenceEqual$1(this.key.boxKey1, keyOffset, this.sav, savOffset, 
                        232) || KeySAVCore.Utility.SequenceEqual$1(this.key.boxKey1, keyOffset, KeySAVCore.Utility.xor$1(this.key.blank, 
                        this.sav, savOffset), 0, 232) || KeySAVCore.Utility.SequenceEqual$1(this.key.boxKey1, 
                        keyOffset, KeySAVCore.Utility.xor$1($t.ezeros, this.sav, savOffset), 0, 232)) {
                        // Data is back to break state, but we can still dump with the other key.
                        ekx = KeySAVCore.Utility.xor$2(this.key.boxKey2, keyOffset, this.sav, savOffset, 
                            232);
                        if (!KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(ekx))) {
                            if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                this.key.blank)))) {
                                ekx = KeySAVCore.Utility.xor(ekx, this.key.blank);
                                KeySAVCore.Utility.xor$3(this.key.blank, 0, this.key.boxKey2, keyOffset, 
                                    this.key.boxKey2, keyOffset, 232);
                            }
                            else
                                if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                    $t.ezeros)))) {
                                    // Key1 decrypts our data after we remove encrypted zeros.
                                    // Copy Key1 to Key2, then zero out Key1.
                                    ekx = KeySAVCore.Utility.xor(ekx, $t.ezeros);
                                    KeySAVCore.Utility.xor$3($t.ezeros, 0, this.key.boxKey2, keyOffset, 
                                        this.key.boxKey2, keyOffset, 232);
                                }
                                else
                                    return null; // Decryption Error
                        }
                    }
                    else
                        if (KeySAVCore.Utility.SequenceEqual$1(this.key.boxKey2, keyOffset, this.sav, 
                            savOffset, 232) || KeySAVCore.Utility.SequenceEqual$1(this.key.boxKey2, keyOffset, 
                            KeySAVCore.Utility.xor$1(this.key.blank, this.sav, savOffset), 0, 232) || KeySAVCore.Utility.SequenceEqual$1(this.key.boxKey2, 
                            keyOffset, KeySAVCore.Utility.xor$1($t.ezeros, this.sav, savOffset), 0, 232)) {
                            // Data is changed only once to a dumpable, but we can still dump with the other key.
                            ekx = KeySAVCore.Utility.xor$2(this.key.boxKey1, keyOffset, this.sav, savOffset, 
                                232);
                            if (!KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(ekx))) {
                                if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                    this.key.blank)))) {
                                    ekx = KeySAVCore.Utility.xor(ekx, this.key.blank);
                                    KeySAVCore.Utility.xor$3(this.key.blank, 0, this.key.boxKey1, keyOffset, 
                                        this.key.boxKey1, keyOffset, 232);
                                }
                                else
                                    if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                        $t.ezeros)))) {
                                        ekx = KeySAVCore.Utility.xor(ekx, $t.ezeros);
                                        KeySAVCore.Utility.xor$3($t.ezeros, 0, this.key.boxKey1, keyOffset, 
                                            this.key.boxKey1, keyOffset, 232);
                                    }
                                    else
                                        return null; // Decryption Error
                            }
                        }
                        else {
                            // Data has been observed to change twice! We can get our exact keystream now!
                            // Either Key1 or Key2 or Save is empty. Whichever one decrypts properly is the empty data.
                            // Oh boy... here we go...
                            ghost.value = false;
                            this.key.slotsUnlocked[slot] = true;
                            var keydata1, keydata2 = false;
                            var data1 = KeySAVCore.Utility.xor$2(this.sav, savOffset, this.key.boxKey1, 
                                keyOffset, 232);
                            var data2 = KeySAVCore.Utility.xor$2(this.sav, savOffset, this.key.boxKey2, 
                                keyOffset, 232);

                            keydata1 = (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(data1)) || KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(data1, 
                                $t.ezeros))) || KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(data1, 
                                this.key.blank))));
                            keydata2 = (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(data2)) || KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(data2, 
                                $t.ezeros))) || KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(data2, 
                                this.key.blank))));

                            var emptyKey, emptyKeyData;
                            var emptyOffset;

                            if (keydata1 && keydata2) {
                                // Save file is currently empty...
                                // Copy key data from save file if it decrypts with Key1 data properly.
                                emptyKey = this.sav;
                                emptyOffset = savOffset;
                                emptyKeyData = data1;
                            }
                            else
                                if (keydata1) { // Key 1 is empty
                                    emptyKey = this.key.boxKey1;
                                    emptyOffset = keyOffset;
                                    emptyKeyData = data1;
                                }
                                else
                                    if (keydata2) { // Key 2 is emtpy
                                        emptyKey = this.key.boxKey2;
                                        emptyOffset = keyOffset;
                                        emptyKeyData = data2;
                                    }
                                    else
                                        return null; // All three are occupied

                            if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(emptyKeyData))) {
                                // No modifications necessary.
                                ekx = emptyKeyData;
                                Array.Copy$3(emptyKey, emptyOffset, this.key.boxKey2, keyOffset, 232);
                                Array.Copy$3($t.zeros, 0, this.key.boxKey1, keyOffset, 232);
                            }
                            else
                                if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(emptyKeyData, 
                                    $t.ezeros)))) {
                                    ekx = $t.ezeros;
                                    KeySAVCore.Utility.xor$3($t.ezeros, 0, emptyKey, emptyOffset, this.key.boxKey2, 
                                        keyOffset, 232);
                                    Array.Copy$3($t.zeros, 0, this.key.boxKey1, keyOffset, 232);
                                }
                                else
                                    if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(emptyKeyData, 
                                        this.key.blank)))) {
                                        ekx = $t.ezeros;
                                        KeySAVCore.Utility.xor$3(this.key.blank, 0, emptyKey, emptyOffset, 
                                            this.key.boxKey2, keyOffset, 232);
                                        Array.Copy$3($t.zeros, 0, this.key.boxKey1, keyOffset, 232);
                                    }
                        }
                }
        var pkx = KeySAVCore.Structures.PKX.decrypt(ekx);
        if (KeySAVCore.Structures.PKX.verifyCHK(pkx)) {
            return pkx;
        }
        else
            return null; // Slot Decryption error?!
    };
    $p.KeySAVCore$ISaveReader$get_KeyName = $p.get_KeyName;
    $p.KeySAVCore$ISaveReader$get_UnlockedSlots = $p.get_UnlockedSlots;
    $p.KeySAVCore$ISaveReader$scanSlots$2 = $p.scanSlots$2;
    $p.KeySAVCore$ISaveReader$scanSlots = $p.scanSlots;
    $p.KeySAVCore$ISaveReader$scanSlots$1 = $p.scanSlots$1;
    $p.KeySAVCore$ISaveReader$getPkx = $p.getPkx;
});
KeySAVCore.Utility = $d.declare("KeySAVCore.Utility", System.Object, 0, $asm, function($t, $p) {
    $t.xor = function Utility_xor(one, two) {
        if (one.length != two.length)
            return null;
        var length = one.length;
        var res = $d.array(System.Byte, length);
        for (var i = 0; i < length; ++i) {
            res[i] = ((one[i] ^ two[i]) & 0xFF);
        }
        return res;
    };
    $t.xor$1 = function Utility_xor(first, second, secondoffset) {
        return $t.xor$2(first, 0, second, secondoffset, $d.toUInt32(first.length));
    };
    $t.xor$2 = function Utility_xor(first, firstOffset, second, secondOffset, length) {
        var res = $d.array(System.Byte, length);
        for (var i = 0; i < length; ++i) {
            res[i] = ((first[firstOffset + i] ^ second[secondOffset + i]) & 0xFF);
        }
        return res;
    };
    $t.xor$3 = function Utility_xor(first, firstOffset, second, secondOffset, target, targetOffset, length) {
        for (var i = 0; i < length; ++i) {
            target[i + targetOffset] = ((first[i + firstOffset] ^ second[i + secondOffset]) & 0xFF);
        }
    };
    $t.XorInPlace = function Utility_XorInPlace(self, offset, other, otherOffset, length) {
        for (var i = 0; i < length; ++i) {
            self[i + offset] = ((self[i + offset] ^ other[i + otherOffset]) & 0xFF);
        }
    };
    $t.SequenceEqual = function Utility_SequenceEqual(self, other, offset) {
        for (var i = 0; i < self.length; ++i) {
            if (self[i] != other[offset + i])
                return false;
        }
        return true;
    };
    $t.SequenceEqual$1 = function Utility_SequenceEqual(one, oneOffset, two, twoOffset, length) {
        for (var i = 0; i < length; ++i) {
            if (one[i + oneOffset] != two[i + twoOffset])
                return false;
        }
        return true;
    };
    $t.Empty = function Utility_Empty(array) {
        return System.Linq.Enumerable.All(System.Byte, array, $d.delegate(function(e) {
            return e == 0;
        }, this));
    };
    $t.Empty$1 = function Utility_Empty(array, offset, length) {
        for (var i = offset; i < offset + length; ++i) {
            if (array[i] != 0)
                return false;
        }
        return true;
    };
    $t.TrimCString = function Utility_TrimCString(str) {
        var index = str.IndexOf(0);
        if (index < 0)
            return str;

        return str.Substring$1(0, index);
    };
    $t.CleanFileName = function Utility_CleanFileName(fileName) {
        return System.Linq.Enumerable.Aggregate$1(System.Char, String, System.IO.Path.GetInvalidFileNameChars(), 
            fileName, $d.delegate(function(current, c) {
                return current.Replace$1(String.fromCharCode(c), String.Empty);
            }, this));
    };
    $t.Switch = function Utility_Switch(T, one, two) {
        var tmp = one.value;
        one.value = two.value;
        two.value = tmp;
    };
});
return $asm;
})();
//# sourceMappingURL=KeySAVCoreJS.js.map
